ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"stm32l4.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.stm32l4_last_sector_to_erase,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	stm32l4_last_sector_to_erase:
  25              	.LFB133:
  26              		.file 1 "Src/cortexm/stm32/stm32l4.c"
   1:Src/cortexm/stm32/stm32l4.c **** /*
   2:Src/cortexm/stm32/stm32l4.c ****  * This file is part of the Black Magic Debug project.
   3:Src/cortexm/stm32/stm32l4.c ****  *
   4:Src/cortexm/stm32/stm32l4.c ****  * Copyright (C) 2011  Black Sphere Technologies Ltd.
   5:Src/cortexm/stm32/stm32l4.c ****  * Written by Gareth McMullin <gareth@blacksphere.co.nz>
   6:Src/cortexm/stm32/stm32l4.c ****  *
   7:Src/cortexm/stm32/stm32l4.c ****  * Copyright (C) 2018  Tomasz Michalec <tomasz.michalec1996@gmail.com>
   8:Src/cortexm/stm32/stm32l4.c ****  *
   9:Src/cortexm/stm32/stm32l4.c ****  * This program is free software: you can redistribute it and/or modify
  10:Src/cortexm/stm32/stm32l4.c ****  * it under the terms of the GNU General Public License as published by
  11:Src/cortexm/stm32/stm32l4.c ****  * the Free Software Foundation, either version 3 of the License, or
  12:Src/cortexm/stm32/stm32l4.c ****  * (at your option) any later version.
  13:Src/cortexm/stm32/stm32l4.c ****  *
  14:Src/cortexm/stm32/stm32l4.c ****  * This program is distributed in the hope that it will be useful,
  15:Src/cortexm/stm32/stm32l4.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:Src/cortexm/stm32/stm32l4.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:Src/cortexm/stm32/stm32l4.c ****  * GNU General Public License for more details.
  18:Src/cortexm/stm32/stm32l4.c ****  *
  19:Src/cortexm/stm32/stm32l4.c ****  * You should have received a copy of the GNU General Public License
  20:Src/cortexm/stm32/stm32l4.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:Src/cortexm/stm32/stm32l4.c ****  */
  22:Src/cortexm/stm32/stm32l4.c **** 
  23:Src/cortexm/stm32/stm32l4.c **** /*
  24:Src/cortexm/stm32/stm32l4.c ****  * What has been modified by Tomasz Michalec:
  25:Src/cortexm/stm32/stm32l4.c ****  *   -- This file is based on stm32f4.c and has a lot of similarites, but implements
  26:Src/cortexm/stm32/stm32l4.c ****  *      functions for different target.
  27:Src/cortexm/stm32/stm32l4.c ****  *   -- stm32l4_flash_write_stub designed for STM32L4xx
  28:Src/cortexm/stm32/stm32l4.c ****  *   -- Add function stm32l4_erase_flash()
  29:Src/cortexm/stm32/stm32l4.c ****  *   -- Add function stm32l4_erase_all_flash()
  30:Src/cortexm/stm32/stm32l4.c ****  *   -- Add function stm32l4_program()
  31:Src/cortexm/stm32/stm32l4.c ****  *   -- Minor changes between stm32f4 and stm32l4
  32:Src/cortexm/stm32/stm32l4.c ****  */
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 2


  33:Src/cortexm/stm32/stm32l4.c **** 
  34:Src/cortexm/stm32/stm32l4.c **** #include "stm32f4xx_it.h"
  35:Src/cortexm/stm32/stm32l4.c **** #include "cmsis_os.h"
  36:Src/cortexm/stm32/stm32l4.c **** #include "cortexm/cortexm.h"
  37:Src/cortexm/stm32/stm32l4.c **** #include "cortexm/stm32/stm32l4.h"
  38:Src/cortexm/stm32/stm32l4.c **** #include "fatfs.h"
  39:Src/cortexm/stm32/stm32l4.c **** #include "target.h"
  40:Src/cortexm/stm32/stm32l4.c **** 
  41:Src/cortexm/stm32/stm32l4.c **** /* This routine is uses word access. */
  42:Src/cortexm/stm32/stm32l4.c **** static uint16_t stm32l4_flash_write_stub[] = {
  43:Src/cortexm/stm32/stm32l4.c **** // 00000000 <_start>:
  44:Src/cortexm/stm32/stm32l4.c ****   0xf8df, 0x002c,     // ldr.w	r0, [pc, #44]	; 30 <_flashbase>
  45:Src/cortexm/stm32/stm32l4.c ****   0x490b,             // ldr	r1, [pc, #44]	; (34 <_addr>)
  46:Src/cortexm/stm32/stm32l4.c ****   0xa20d,             // add	r2, pc, #52	; (adr r2, 3c <_data>)
  47:Src/cortexm/stm32/stm32l4.c ****   0x4b0b,             // ldr	r3, [pc, #44]	; (38 <_size>)
  48:Src/cortexm/stm32/stm32l4.c ****   0x4d08,             // ldr	r5, [pc, #32]	; (2c <_cr>)
  49:Src/cortexm/stm32/stm32l4.c **** 
  50:Src/cortexm/stm32/stm32l4.c **** // 0000000c <_next>:
  51:Src/cortexm/stm32/stm32l4.c ****   0xb16b,             // cbz	r3, 2a <_done>
  52:Src/cortexm/stm32/stm32l4.c ****   0x6145,             // str	r5, [r0, #20]
  53:Src/cortexm/stm32/stm32l4.c ****   0x6814,             // ldr	r4, [r2, #0]
  54:Src/cortexm/stm32/stm32l4.c ****   0x600c,             // str	r4, [r1, #0]
  55:Src/cortexm/stm32/stm32l4.c **** 
  56:Src/cortexm/stm32/stm32l4.c **** //00000014 <_wait>:
  57:Src/cortexm/stm32/stm32l4.c ****   0x6904,             // ldr	r4, [r0, #16]
  58:Src/cortexm/stm32/stm32l4.c ****   0xf416, 0x3f80,     // tst.w	r6, #65536	; 0x10000
  59:Src/cortexm/stm32/stm32l4.c ****   0xd1fb,             // bne.n	14 <_wait>
  60:Src/cortexm/stm32/stm32l4.c ****   0xf016, 0x0ffa,     // tst.w	r6, #250	; 0xfa
  61:Src/cortexm/stm32/stm32l4.c ****   0xd103,             // bne.n	2a <_done>
  62:Src/cortexm/stm32/stm32l4.c ****   0x3b04,             // subs	r3, #4
  63:Src/cortexm/stm32/stm32l4.c ****   0x3104,             // adds	r1, #4
  64:Src/cortexm/stm32/stm32l4.c ****   0x3204,             // adds	r2, #4
  65:Src/cortexm/stm32/stm32l4.c ****   0xe7f0,             // b.n	c <_next>
  66:Src/cortexm/stm32/stm32l4.c **** 
  67:Src/cortexm/stm32/stm32l4.c **** //0000002a <_done>:
  68:Src/cortexm/stm32/stm32l4.c ****   0xbe00,             // bkpt	0x0000
  69:Src/cortexm/stm32/stm32l4.c **** 
  70:Src/cortexm/stm32/stm32l4.c **** //0000002c <_cr>:
  71:Src/cortexm/stm32/stm32l4.c ****   0x0001, 0x0000,     //.word	0x00000001
  72:Src/cortexm/stm32/stm32l4.c **** 
  73:Src/cortexm/stm32/stm32l4.c **** //00000030 <_flashbase>:
  74:Src/cortexm/stm32/stm32l4.c ****   0x2000, 0x4002,     //.word	0x40022000
  75:Src/cortexm/stm32/stm32l4.c **** 
  76:Src/cortexm/stm32/stm32l4.c **** //00000034 <_addr>:
  77:Src/cortexm/stm32/stm32l4.c ****   0x0000, 0x0000,     //.word	0x00000000
  78:Src/cortexm/stm32/stm32l4.c **** 
  79:Src/cortexm/stm32/stm32l4.c **** //00000038 <_size>:
  80:Src/cortexm/stm32/stm32l4.c ****   0x0000, 0x0000      //.word	0x00000000
  81:Src/cortexm/stm32/stm32l4.c **** 
  82:Src/cortexm/stm32/stm32l4.c **** //  0000003c <_data>:
  83:Src/cortexm/stm32/stm32l4.c **** };
  84:Src/cortexm/stm32/stm32l4.c **** 
  85:Src/cortexm/stm32/stm32l4.c **** static void stm32l4_flash_unlock(STM32L4_PRIV_t *priv)
  86:Src/cortexm/stm32/stm32l4.c **** {
  87:Src/cortexm/stm32/stm32l4.c ****   printf("Flash unlock\n");
  88:Src/cortexm/stm32/stm32l4.c ****   if (priv->cortex->ops->read_word(priv->cortex->priv, STM32L4_FLASH_CR) & STM32L4_FLASH_CR_LOCK) {
  89:Src/cortexm/stm32/stm32l4.c ****     /* Enable FPEC controller access */
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 3


  90:Src/cortexm/stm32/stm32l4.c ****     priv->cortex->ops->write_word(priv->cortex->priv, STM32L4_FLASH_KEYR, STM32L4_KEY1);
  91:Src/cortexm/stm32/stm32l4.c ****     priv->cortex->ops->write_word(priv->cortex->priv, STM32L4_FLASH_KEYR, STM32L4_KEY2);
  92:Src/cortexm/stm32/stm32l4.c ****   }
  93:Src/cortexm/stm32/stm32l4.c ****   // Clear flash error
  94:Src/cortexm/stm32/stm32l4.c ****   priv->cortex->ops->write_word(priv->cortex->priv, STM32L4_FLASH_SR, STM32L4_FLASH_SR_ERROR_MASK);
  95:Src/cortexm/stm32/stm32l4.c **** }
  96:Src/cortexm/stm32/stm32l4.c **** 
  97:Src/cortexm/stm32/stm32l4.c **** static int stm32l4_erase_all_flash(STM32L4_PRIV_t *priv, int *progress, int progress_end)
  98:Src/cortexm/stm32/stm32l4.c **** {
  99:Src/cortexm/stm32/stm32l4.c ****   uint16_t sr;
 100:Src/cortexm/stm32/stm32l4.c ****   int time = 0;
 101:Src/cortexm/stm32/stm32l4.c ****   int progress_step = progress_end/10;
 102:Src/cortexm/stm32/stm32l4.c **** 
 103:Src/cortexm/stm32/stm32l4.c ****   /* Flash mass erase start instruction */
 104:Src/cortexm/stm32/stm32l4.c ****   priv->cortex->ops->write_word(priv->cortex->priv, STM32L4_FLASH_CR, STM32L4_FLASH_CR_MER1 | STM32
 105:Src/cortexm/stm32/stm32l4.c ****   priv->cortex->ops->write_word(priv->cortex->priv, STM32L4_FLASH_CR, STM32L4_FLASH_CR_STRT | STM32
 106:Src/cortexm/stm32/stm32l4.c **** 
 107:Src/cortexm/stm32/stm32l4.c ****   /* Read FLASH_SR to poll for BSY bit */
 108:Src/cortexm/stm32/stm32l4.c ****   while(priv->cortex->ops->read_word(priv->cortex->priv, STM32L4_FLASH_SR) & STM32L4_FLASH_SR_BSY) 
 109:Src/cortexm/stm32/stm32l4.c ****     if(priv->cortex->ops->check_error(priv->cortex->priv)) {
 110:Src/cortexm/stm32/stm32l4.c ****       // TODO: handle error
 111:Src/cortexm/stm32/stm32l4.c ****       printf("Error while waiting for erase end\n");
 112:Src/cortexm/stm32/stm32l4.c ****       return STM32L4_ERASE_NEVER_END;
 113:Src/cortexm/stm32/stm32l4.c ****     }
 114:Src/cortexm/stm32/stm32l4.c ****     osDelay(10);
 115:Src/cortexm/stm32/stm32l4.c ****     time++;
 116:Src/cortexm/stm32/stm32l4.c ****     // after each 100 loops add one to progress, we asume that whole erase will take 1000 loops
 117:Src/cortexm/stm32/stm32l4.c ****     if(time > 100) {
 118:Src/cortexm/stm32/stm32l4.c ****       time = 0;
 119:Src/cortexm/stm32/stm32l4.c ****       if(*progress < progress_end - progress_step) {
 120:Src/cortexm/stm32/stm32l4.c ****         *progress += progress_step;
 121:Src/cortexm/stm32/stm32l4.c ****         printf("Flash progress %d\n", *progress);
 122:Src/cortexm/stm32/stm32l4.c ****       }
 123:Src/cortexm/stm32/stm32l4.c ****     }
 124:Src/cortexm/stm32/stm32l4.c ****   }
 125:Src/cortexm/stm32/stm32l4.c **** 
 126:Src/cortexm/stm32/stm32l4.c ****   /* Check for error */
 127:Src/cortexm/stm32/stm32l4.c ****   sr = priv->cortex->ops->read_word(priv->cortex->priv, STM32L4_FLASH_SR);
 128:Src/cortexm/stm32/stm32l4.c ****   if ((sr & STM32L4_SR_ERROR_MASK) || !(sr & STM32L4_SR_EOP)) {
 129:Src/cortexm/stm32/stm32l4.c ****     // TODO: handle error
 130:Src/cortexm/stm32/stm32l4.c ****     printf("Error after erase 0x%x\n", sr);
 131:Src/cortexm/stm32/stm32l4.c ****     return sr | STM32L4_ERASE_ERROR_BIT;
 132:Src/cortexm/stm32/stm32l4.c ****   }
 133:Src/cortexm/stm32/stm32l4.c **** 
 134:Src/cortexm/stm32/stm32l4.c ****   // End of erase, update progress
 135:Src/cortexm/stm32/stm32l4.c ****   *progress = progress_end;
 136:Src/cortexm/stm32/stm32l4.c ****   return 0;
 137:Src/cortexm/stm32/stm32l4.c **** }
 138:Src/cortexm/stm32/stm32l4.c **** 
 139:Src/cortexm/stm32/stm32l4.c **** // This function return how many sectors is needed to save len bytes.
 140:Src/cortexm/stm32/stm32l4.c **** // If len is bigger then 64 sectors, return bigger number than number of sectors
 141:Src/cortexm/stm32/stm32l4.c **** static uint16_t stm32l4_last_sector_to_erase(int len)
 142:Src/cortexm/stm32/stm32l4.c **** {
  27              		.loc 1 142 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 4


  31              		@ link register save eliminated.
  32              	.LVL0:
 143:Src/cortexm/stm32/stm32l4.c ****   uint16_t sectors = len/STM32L4_PAGE_SIZE;
  33              		.loc 1 143 0
  34 0000 0028     		cmp	r0, #0
  35 0002 04DB     		blt	.L5
  36              	.LVL1:
  37              	.L2:
  38 0004 C0F3CF20 		ubfx	r0, r0, #11, #16
  39              	.LVL2:
 144:Src/cortexm/stm32/stm32l4.c ****   return sectors <= 63 ? sectors : 1024;
  40              		.loc 1 144 0
  41 0008 3F28     		cmp	r0, #63
  42 000a 03D8     		bhi	.L6
  43              	.LVL3:
  44              	.L3:
 145:Src/cortexm/stm32/stm32l4.c **** }
  45              		.loc 1 145 0 discriminator 4
  46 000c 7047     		bx	lr
  47              	.LVL4:
  48              	.L5:
 143:Src/cortexm/stm32/stm32l4.c ****   uint16_t sectors = len/STM32L4_PAGE_SIZE;
  49              		.loc 1 143 0
  50 000e 00F2FF70 		addw	r0, r0, #2047
  51              	.LVL5:
  52 0012 F7E7     		b	.L2
  53              	.LVL6:
  54              	.L6:
 144:Src/cortexm/stm32/stm32l4.c ****   return sectors <= 63 ? sectors : 1024;
  55              		.loc 1 144 0
  56 0014 4FF48060 		mov	r0, #1024
  57              	.LVL7:
  58 0018 F8E7     		b	.L3
  59              		.cfi_endproc
  60              	.LFE133:
  62              		.section	.text.stm32l4_restart,"ax",%progbits
  63              		.align	1
  64              		.syntax unified
  65              		.thumb
  66              		.thumb_func
  67              		.fpu fpv4-sp-d16
  69              	stm32l4_restart:
  70              	.LFB137:
 146:Src/cortexm/stm32/stm32l4.c **** 
 147:Src/cortexm/stm32/stm32l4.c **** static int stm32l4_erase_flash(STM32L4_PRIV_t *priv, int len, int *progress, int progress_end)
 148:Src/cortexm/stm32/stm32l4.c **** {
 149:Src/cortexm/stm32/stm32l4.c ****   uint16_t sr;
 150:Src/cortexm/stm32/stm32l4.c ****   uint32_t cr;
 151:Src/cortexm/stm32/stm32l4.c ****   uint16_t last_sector_to_flash = stm32l4_last_sector_to_erase(len);
 152:Src/cortexm/stm32/stm32l4.c ****   int progress_step = (progress_end + 511)/512;
 153:Src/cortexm/stm32/stm32l4.c **** 
 154:Src/cortexm/stm32/stm32l4.c ****   printf("Erase Flash\n");
 155:Src/cortexm/stm32/stm32l4.c ****   // TODO: For simplicity only when writing less than 64 sectors (2KB each) optimal sector erase
 156:Src/cortexm/stm32/stm32l4.c ****   //       algorithm is used. First 64 sectors are always present which is independent
 157:Src/cortexm/stm32/stm32l4.c ****   //       of size of flash memory.
 158:Src/cortexm/stm32/stm32l4.c ****   if(last_sector_to_flash > 63) {
 159:Src/cortexm/stm32/stm32l4.c ****     return stm32l4_erase_all_flash(priv, progress, progress_end);
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 5


 160:Src/cortexm/stm32/stm32l4.c ****   }
 161:Src/cortexm/stm32/stm32l4.c **** 
 162:Src/cortexm/stm32/stm32l4.c ****   for(uint8_t sector = 0; sector <= last_sector_to_flash; sector++) {
 163:Src/cortexm/stm32/stm32l4.c ****     cr = STM32L4_FLASH_CR_EOPIE | STM32L4_FLASH_CR_ERRIE | STM32L4_FLASH_CR_PER;
 164:Src/cortexm/stm32/stm32l4.c ****     cr |= sector << STM32L4_FLASH_CR_PAGE_SHIFT;
 165:Src/cortexm/stm32/stm32l4.c ****     /* Flash page erase instruction */
 166:Src/cortexm/stm32/stm32l4.c ****     priv->cortex->ops->write_word(priv->cortex->priv, STM32L4_FLASH_CR, cr);
 167:Src/cortexm/stm32/stm32l4.c ****     /* write address to FMA */
 168:Src/cortexm/stm32/stm32l4.c ****     priv->cortex->ops->write_word(priv->cortex->priv, STM32L4_FLASH_CR, cr | STM32L4_FLASH_CR_STRT)
 169:Src/cortexm/stm32/stm32l4.c ****     /* Read FLASH_SR to poll for BSY bit */
 170:Src/cortexm/stm32/stm32l4.c ****     while(priv->cortex->ops->read_word(priv->cortex->priv, STM32L4_FLASH_SR) & STM32L4_FLASH_SR_BSY
 171:Src/cortexm/stm32/stm32l4.c ****       if(priv->cortex->ops->check_error(priv->cortex->priv)) {
 172:Src/cortexm/stm32/stm32l4.c ****         // TODO: handle error
 173:Src/cortexm/stm32/stm32l4.c ****         printf("Error while waiting for erase end\n");
 174:Src/cortexm/stm32/stm32l4.c ****         return STM32L4_ERASE_NEVER_END;
 175:Src/cortexm/stm32/stm32l4.c ****       }
 176:Src/cortexm/stm32/stm32l4.c ****     }
 177:Src/cortexm/stm32/stm32l4.c ****     *progress += progress_step;
 178:Src/cortexm/stm32/stm32l4.c ****     printf("Flash progress %d\n", *progress);
 179:Src/cortexm/stm32/stm32l4.c ****   }
 180:Src/cortexm/stm32/stm32l4.c **** 
 181:Src/cortexm/stm32/stm32l4.c ****   /* Check for error */
 182:Src/cortexm/stm32/stm32l4.c ****   sr = priv->cortex->ops->read_word(priv->cortex->priv, STM32L4_FLASH_SR);
 183:Src/cortexm/stm32/stm32l4.c ****   if ((sr & STM32L4_SR_ERROR_MASK) || !(sr & STM32L4_SR_EOP)) {
 184:Src/cortexm/stm32/stm32l4.c ****     // TODO: handle error
 185:Src/cortexm/stm32/stm32l4.c ****     printf("Error after erase 0x%x\n", sr);
 186:Src/cortexm/stm32/stm32l4.c ****     return sr | STM32L4_ERASE_ERROR_BIT;
 187:Src/cortexm/stm32/stm32l4.c ****   }
 188:Src/cortexm/stm32/stm32l4.c **** 
 189:Src/cortexm/stm32/stm32l4.c ****   return 0;
 190:Src/cortexm/stm32/stm32l4.c **** }
 191:Src/cortexm/stm32/stm32l4.c **** 
 192:Src/cortexm/stm32/stm32l4.c **** static int stm32l4_flash_write(STM32L4_PRIV_t *priv, uint32_t dest, const uint32_t *src, int len)
 193:Src/cortexm/stm32/stm32l4.c **** {
 194:Src/cortexm/stm32/stm32l4.c ****   uint32_t start_of_ram = 0x20000000;
 195:Src/cortexm/stm32/stm32l4.c ****   uint32_t stub_len = 0x3c;
 196:Src/cortexm/stm32/stm32l4.c ****   uint16_t sr;
 197:Src/cortexm/stm32/stm32l4.c **** 
 198:Src/cortexm/stm32/stm32l4.c ****   /* Fill stm32l4_flash_write_stub with address and size */
 199:Src/cortexm/stm32/stm32l4.c **** 	*(uint32_t *)&(stm32l4_flash_write_stub[26]) = dest;
 200:Src/cortexm/stm32/stm32l4.c ****   *(uint32_t *)&(stm32l4_flash_write_stub[28]) = len;
 201:Src/cortexm/stm32/stm32l4.c **** 
 202:Src/cortexm/stm32/stm32l4.c ****   /* Write stub and data to target ram and set PC */
 203:Src/cortexm/stm32/stm32l4.c ****   priv->cortex->ops->write_words(priv->cortex->priv, start_of_ram, (void*)stm32l4_flash_write_stub,
 204:Src/cortexm/stm32/stm32l4.c ****   priv->cortex->ops->write_words(priv->cortex->priv, start_of_ram + stub_len, src, len);
 205:Src/cortexm/stm32/stm32l4.c ****   priv->cortex->ops->pc_write(priv->cortex->priv, start_of_ram);
 206:Src/cortexm/stm32/stm32l4.c ****   if(priv->cortex->ops->check_error(priv->cortex->priv)) {
 207:Src/cortexm/stm32/stm32l4.c ****     // TODO: handle error
 208:Src/cortexm/stm32/stm32l4.c ****     printf("ERROR: Filed to setup write operation\n");
 209:Src/cortexm/stm32/stm32l4.c ****     return STM32L4_ERROR_ON_FLASH_WRITE_SETUP;
 210:Src/cortexm/stm32/stm32l4.c ****   }
 211:Src/cortexm/stm32/stm32l4.c **** 
 212:Src/cortexm/stm32/stm32l4.c ****   /* Execute the stub */
 213:Src/cortexm/stm32/stm32l4.c ****   priv->cortex->ops->halt_resume(priv->cortex->priv);
 214:Src/cortexm/stm32/stm32l4.c ****   while(!priv->cortex->ops->halt_wait(priv->cortex->priv)) {
 215:Src/cortexm/stm32/stm32l4.c ****     // Don't be greedy about CPU, allow another task
 216:Src/cortexm/stm32/stm32l4.c ****     osDelay(10);
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 6


 217:Src/cortexm/stm32/stm32l4.c ****   }
 218:Src/cortexm/stm32/stm32l4.c **** 
 219:Src/cortexm/stm32/stm32l4.c ****   /* Check for error */
 220:Src/cortexm/stm32/stm32l4.c ****   sr = priv->cortex->ops->read_word(priv->cortex->priv, STM32L4_FLASH_SR);
 221:Src/cortexm/stm32/stm32l4.c ****   if (sr & STM32L4_SR_ERROR_MASK) {
 222:Src/cortexm/stm32/stm32l4.c ****     // TODO: handle error
 223:Src/cortexm/stm32/stm32l4.c ****     printf("ERROR: writing ended with error 0x%x\n", sr);
 224:Src/cortexm/stm32/stm32l4.c ****     return sr | STM32L4_FLASH_ERROR_BIT;
 225:Src/cortexm/stm32/stm32l4.c ****   }
 226:Src/cortexm/stm32/stm32l4.c **** 
 227:Src/cortexm/stm32/stm32l4.c ****   return 0;
 228:Src/cortexm/stm32/stm32l4.c **** }
 229:Src/cortexm/stm32/stm32l4.c **** 
 230:Src/cortexm/stm32/stm32l4.c **** static int stm32l4_program(void *priv_void, FIL *file, int *progress)
 231:Src/cortexm/stm32/stm32l4.c **** {
 232:Src/cortexm/stm32/stm32l4.c ****   UINT br;
 233:Src/cortexm/stm32/stm32l4.c ****   uint8_t unaligned;
 234:Src/cortexm/stm32/stm32l4.c ****   uint32_t addr = 0x8000000; // start of flash memory
 235:Src/cortexm/stm32/stm32l4.c ****   uint32_t *data = pvPortMalloc(STM32L4_SIZE_OF_ONE_WRITE);
 236:Src/cortexm/stm32/stm32l4.c ****   STM32L4_PRIV_t *priv = priv_void;
 237:Src/cortexm/stm32/stm32l4.c ****   uint16_t result;
 238:Src/cortexm/stm32/stm32l4.c ****   uint32_t file_len = f_size(file);
 239:Src/cortexm/stm32/stm32l4.c **** 
 240:Src/cortexm/stm32/stm32l4.c ****   // these variables are only needed to show progress
 241:Src/cortexm/stm32/stm32l4.c ****   int number_of_writes = (file_len + STM32L4_SIZE_OF_ONE_WRITE - 1)/STM32L4_SIZE_OF_ONE_WRITE;
 242:Src/cortexm/stm32/stm32l4.c ****   float progress_as_float = 100 * STM32L4_ERASE_TIME_IN_WRITES/(number_of_writes + STM32L4_ERASE_TI
 243:Src/cortexm/stm32/stm32l4.c ****   float progress_on_one_write;
 244:Src/cortexm/stm32/stm32l4.c **** 
 245:Src/cortexm/stm32/stm32l4.c ****   printf("Start flashing STM32L4x\n");
 246:Src/cortexm/stm32/stm32l4.c **** 
 247:Src/cortexm/stm32/stm32l4.c ****   priv->cortex->ops->halt_request(priv->cortex->priv);
 248:Src/cortexm/stm32/stm32l4.c ****   stm32l4_flash_unlock(priv);
 249:Src/cortexm/stm32/stm32l4.c ****   result = stm32l4_erase_flash(priv, file_len, progress, progress_as_float);
 250:Src/cortexm/stm32/stm32l4.c ****   if(result) {
 251:Src/cortexm/stm32/stm32l4.c ****     vPortFree(data);
 252:Src/cortexm/stm32/stm32l4.c ****     return result;
 253:Src/cortexm/stm32/stm32l4.c ****   }
 254:Src/cortexm/stm32/stm32l4.c **** 
 255:Src/cortexm/stm32/stm32l4.c ****   progress_as_float = *progress;
 256:Src/cortexm/stm32/stm32l4.c ****   progress_on_one_write = (100 - *progress)/number_of_writes;
 257:Src/cortexm/stm32/stm32l4.c **** 
 258:Src/cortexm/stm32/stm32l4.c ****   do {
 259:Src/cortexm/stm32/stm32l4.c ****     f_read(file, data, STM32L4_SIZE_OF_ONE_WRITE, &br);
 260:Src/cortexm/stm32/stm32l4.c ****     printf("flash 0x%x bytes on 0x%lx\n", br, addr);
 261:Src/cortexm/stm32/stm32l4.c ****     unaligned = br & 0x3;
 262:Src/cortexm/stm32/stm32l4.c ****     if (unaligned) {
 263:Src/cortexm/stm32/stm32l4.c ****       // If number of readed bytes % sizeof(uint32_t) != 0, last readed bytes are unaligned.
 264:Src/cortexm/stm32/stm32l4.c ****       // Fill all unreaded bytes in last 4 bytes as 0xFF. This way flash is not damaged
 265:Src/cortexm/stm32/stm32l4.c ****       // by writing additional (1..3) bytes.
 266:Src/cortexm/stm32/stm32l4.c ****       br >>= 2;
 267:Src/cortexm/stm32/stm32l4.c ****       data[br] |= ((~0) >> (unaligned << 0x3));
 268:Src/cortexm/stm32/stm32l4.c ****       // add modified bytes to bytes that will be written
 269:Src/cortexm/stm32/stm32l4.c ****       br++;
 270:Src/cortexm/stm32/stm32l4.c ****       br <<= 2;
 271:Src/cortexm/stm32/stm32l4.c ****       result = stm32l4_flash_write(priv, addr, data, br);
 272:Src/cortexm/stm32/stm32l4.c ****       if(result) {
 273:Src/cortexm/stm32/stm32l4.c ****         vPortFree(data);
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 7


 274:Src/cortexm/stm32/stm32l4.c ****         return result;
 275:Src/cortexm/stm32/stm32l4.c ****       }
 276:Src/cortexm/stm32/stm32l4.c ****       // Unaligned read is always smaller then SIZE_OF_ONE_WRITE.
 277:Src/cortexm/stm32/stm32l4.c ****       // This is EOF so we have done here.
 278:Src/cortexm/stm32/stm32l4.c ****       break;
 279:Src/cortexm/stm32/stm32l4.c ****     }
 280:Src/cortexm/stm32/stm32l4.c ****     result = stm32l4_flash_write(priv, addr, data, br);
 281:Src/cortexm/stm32/stm32l4.c ****     if(result) {
 282:Src/cortexm/stm32/stm32l4.c ****       vPortFree(data);
 283:Src/cortexm/stm32/stm32l4.c ****       return 1;
 284:Src/cortexm/stm32/stm32l4.c ****     }
 285:Src/cortexm/stm32/stm32l4.c ****     addr += br;
 286:Src/cortexm/stm32/stm32l4.c **** 
 287:Src/cortexm/stm32/stm32l4.c ****     progress_as_float += progress_on_one_write;
 288:Src/cortexm/stm32/stm32l4.c ****     *progress = (int)progress_as_float;
 289:Src/cortexm/stm32/stm32l4.c ****     printf("Flash progress %d\n", *progress);
 290:Src/cortexm/stm32/stm32l4.c **** 
 291:Src/cortexm/stm32/stm32l4.c ****     // EOF is when readed less bytes than requested
 292:Src/cortexm/stm32/stm32l4.c ****   } while(br == STM32L4_SIZE_OF_ONE_WRITE);
 293:Src/cortexm/stm32/stm32l4.c **** 
 294:Src/cortexm/stm32/stm32l4.c ****   vPortFree(data);
 295:Src/cortexm/stm32/stm32l4.c **** 
 296:Src/cortexm/stm32/stm32l4.c ****   printf("Device flashed\nReset device\n");
 297:Src/cortexm/stm32/stm32l4.c ****   priv->cortex->ops->restart(priv->cortex->priv);
 298:Src/cortexm/stm32/stm32l4.c **** 
 299:Src/cortexm/stm32/stm32l4.c ****   *progress = 100;
 300:Src/cortexm/stm32/stm32l4.c ****   return 0;
 301:Src/cortexm/stm32/stm32l4.c **** }
 302:Src/cortexm/stm32/stm32l4.c **** 
 303:Src/cortexm/stm32/stm32l4.c **** static void stm32l4_restart(void *priv)
 304:Src/cortexm/stm32/stm32l4.c **** {
  71              		.loc 1 304 0
  72              		.cfi_startproc
  73              		@ args = 0, pretend = 0, frame = 0
  74              		@ frame_needed = 0, uses_anonymous_args = 0
  75              	.LVL8:
  76 0000 08B5     		push	{r3, lr}
  77              	.LCFI0:
  78              		.cfi_def_cfa_offset 8
  79              		.cfi_offset 3, -8
  80              		.cfi_offset 14, -4
 305:Src/cortexm/stm32/stm32l4.c ****   ((STM32L4_PRIV_t*)priv)->cortex->ops->restart(((STM32L4_PRIV_t*)priv)->cortex->priv);
  81              		.loc 1 305 0
  82 0002 0368     		ldr	r3, [r0]
  83 0004 1A68     		ldr	r2, [r3]
  84 0006 926A     		ldr	r2, [r2, #40]
  85 0008 5868     		ldr	r0, [r3, #4]
  86              	.LVL9:
  87 000a 9047     		blx	r2
  88              	.LVL10:
 306:Src/cortexm/stm32/stm32l4.c **** }
  89              		.loc 1 306 0
  90 000c 08BD     		pop	{r3, pc}
  91              		.cfi_endproc
  92              	.LFE137:
  94              		.section	.text.stm32l4_free_priv,"ax",%progbits
  95              		.align	1
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 8


  96              		.syntax unified
  97              		.thumb
  98              		.thumb_func
  99              		.fpu fpv4-sp-d16
 101              	stm32l4_free_priv:
 102              	.LFB138:
 307:Src/cortexm/stm32/stm32l4.c **** 
 308:Src/cortexm/stm32/stm32l4.c **** static void stm32l4_free_priv(void *priv){
 103              		.loc 1 308 0
 104              		.cfi_startproc
 105              		@ args = 0, pretend = 0, frame = 0
 106              		@ frame_needed = 0, uses_anonymous_args = 0
 107              	.LVL11:
 108 0000 10B5     		push	{r4, lr}
 109              	.LCFI1:
 110              		.cfi_def_cfa_offset 8
 111              		.cfi_offset 4, -8
 112              		.cfi_offset 14, -4
 113 0002 0446     		mov	r4, r0
 309:Src/cortexm/stm32/stm32l4.c ****   ((STM32L4_PRIV_t*)priv)->cortex->ops->free(((STM32L4_PRIV_t*)priv)->cortex);
 114              		.loc 1 309 0
 115 0004 0068     		ldr	r0, [r0]
 116              	.LVL12:
 117 0006 0368     		ldr	r3, [r0]
 118 0008 DB6A     		ldr	r3, [r3, #44]
 119 000a 9847     		blx	r3
 120              	.LVL13:
 310:Src/cortexm/stm32/stm32l4.c ****   vPortFree(priv);
 121              		.loc 1 310 0
 122 000c 2046     		mov	r0, r4
 123 000e FFF7FEFF 		bl	vPortFree
 124              	.LVL14:
 311:Src/cortexm/stm32/stm32l4.c **** }
 125              		.loc 1 311 0
 126 0012 10BD     		pop	{r4, pc}
 127              		.cfi_endproc
 128              	.LFE138:
 130              		.section	.text.stm32l4_flash_unlock,"ax",%progbits
 131              		.align	1
 132              		.syntax unified
 133              		.thumb
 134              		.thumb_func
 135              		.fpu fpv4-sp-d16
 137              	stm32l4_flash_unlock:
 138              	.LFB131:
  86:Src/cortexm/stm32/stm32l4.c ****   printf("Flash unlock\n");
 139              		.loc 1 86 0
 140              		.cfi_startproc
 141              		@ args = 0, pretend = 0, frame = 0
 142              		@ frame_needed = 0, uses_anonymous_args = 0
 143              	.LVL15:
 144 0000 70B5     		push	{r4, r5, r6, lr}
 145              	.LCFI2:
 146              		.cfi_def_cfa_offset 16
 147              		.cfi_offset 4, -16
 148              		.cfi_offset 5, -12
 149              		.cfi_offset 6, -8
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 9


 150              		.cfi_offset 14, -4
 151 0002 0446     		mov	r4, r0
  87:Src/cortexm/stm32/stm32l4.c ****   if (priv->cortex->ops->read_word(priv->cortex->priv, STM32L4_FLASH_CR) & STM32L4_FLASH_CR_LOCK) {
 152              		.loc 1 87 0
 153 0004 1148     		ldr	r0, .L14
 154              	.LVL16:
 155 0006 FFF7FEFF 		bl	puts
 156              	.LVL17:
  88:Src/cortexm/stm32/stm32l4.c ****     /* Enable FPEC controller access */
 157              		.loc 1 88 0
 158 000a 2368     		ldr	r3, [r4]
 159 000c 1A68     		ldr	r2, [r3]
 160 000e 1268     		ldr	r2, [r2]
 161 0010 0F49     		ldr	r1, .L14+4
 162 0012 5868     		ldr	r0, [r3, #4]
 163 0014 9047     		blx	r2
 164              	.LVL18:
 165 0016 0028     		cmp	r0, #0
 166 0018 0EDA     		bge	.L12
  90:Src/cortexm/stm32/stm32l4.c ****     priv->cortex->ops->write_word(priv->cortex->priv, STM32L4_FLASH_KEYR, STM32L4_KEY2);
 167              		.loc 1 90 0
 168 001a 2368     		ldr	r3, [r4]
 169 001c 1A68     		ldr	r2, [r3]
 170 001e 5668     		ldr	r6, [r2, #4]
 171 0020 0C4D     		ldr	r5, .L14+8
 172 0022 0D4A     		ldr	r2, .L14+12
 173 0024 2946     		mov	r1, r5
 174 0026 5868     		ldr	r0, [r3, #4]
 175 0028 B047     		blx	r6
 176              	.LVL19:
  91:Src/cortexm/stm32/stm32l4.c ****   }
 177              		.loc 1 91 0
 178 002a 2368     		ldr	r3, [r4]
 179 002c 1A68     		ldr	r2, [r3]
 180 002e 5668     		ldr	r6, [r2, #4]
 181 0030 0A4A     		ldr	r2, .L14+16
 182 0032 2946     		mov	r1, r5
 183 0034 5868     		ldr	r0, [r3, #4]
 184 0036 B047     		blx	r6
 185              	.LVL20:
 186              	.L12:
  94:Src/cortexm/stm32/stm32l4.c **** }
 187              		.loc 1 94 0
 188 0038 2368     		ldr	r3, [r4]
 189 003a 1A68     		ldr	r2, [r3]
 190 003c 5468     		ldr	r4, [r2, #4]
 191              	.LVL21:
 192 003e 4CF2FA32 		movw	r2, #50170
 193 0042 0749     		ldr	r1, .L14+20
 194 0044 5868     		ldr	r0, [r3, #4]
 195 0046 A047     		blx	r4
 196              	.LVL22:
  95:Src/cortexm/stm32/stm32l4.c **** 
 197              		.loc 1 95 0
 198 0048 70BD     		pop	{r4, r5, r6, pc}
 199              	.L15:
 200 004a 00BF     		.align	2
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 10


 201              	.L14:
 202 004c 00000000 		.word	.LC0
 203 0050 14200240 		.word	1073881108
 204 0054 08200240 		.word	1073881096
 205 0058 23016745 		.word	1164378403
 206 005c AB89EFCD 		.word	-839939669
 207 0060 10200240 		.word	1073881104
 208              		.cfi_endproc
 209              	.LFE131:
 211              		.section	.text.stm32l4_erase_all_flash,"ax",%progbits
 212              		.align	1
 213              		.syntax unified
 214              		.thumb
 215              		.thumb_func
 216              		.fpu fpv4-sp-d16
 218              	stm32l4_erase_all_flash:
 219              	.LFB132:
  98:Src/cortexm/stm32/stm32l4.c ****   uint16_t sr;
 220              		.loc 1 98 0
 221              		.cfi_startproc
 222              		@ args = 0, pretend = 0, frame = 0
 223              		@ frame_needed = 0, uses_anonymous_args = 0
 224              	.LVL23:
 225 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 226              	.LCFI3:
 227              		.cfi_def_cfa_offset 32
 228              		.cfi_offset 3, -32
 229              		.cfi_offset 4, -28
 230              		.cfi_offset 5, -24
 231              		.cfi_offset 6, -20
 232              		.cfi_offset 7, -16
 233              		.cfi_offset 8, -12
 234              		.cfi_offset 9, -8
 235              		.cfi_offset 14, -4
 236 0004 0546     		mov	r5, r0
 237 0006 8846     		mov	r8, r1
 238 0008 1746     		mov	r7, r2
 239              	.LVL24:
 101:Src/cortexm/stm32/stm32l4.c **** 
 240              		.loc 1 101 0
 241 000a 2C4B     		ldr	r3, .L29
 242 000c 83FB0723 		smull	r2, r3, r3, r7
 243              	.LVL25:
 244 0010 FE17     		asrs	r6, r7, #31
 245 0012 C6EBA306 		rsb	r6, r6, r3, asr #2
 246              	.LVL26:
 104:Src/cortexm/stm32/stm32l4.c ****   priv->cortex->ops->write_word(priv->cortex->priv, STM32L4_FLASH_CR, STM32L4_FLASH_CR_STRT | STM32
 247              		.loc 1 104 0
 248 0016 0368     		ldr	r3, [r0]
 249 0018 1A68     		ldr	r2, [r3]
 250 001a D2F80490 		ldr	r9, [r2, #4]
 251 001e 284C     		ldr	r4, .L29+4
 252 0020 48F20402 		movw	r2, #32772
 253 0024 2146     		mov	r1, r4
 254              	.LVL27:
 255 0026 5868     		ldr	r0, [r3, #4]
 256              	.LVL28:
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 11


 257 0028 C847     		blx	r9
 258              	.LVL29:
 105:Src/cortexm/stm32/stm32l4.c **** 
 259              		.loc 1 105 0
 260 002a 2B68     		ldr	r3, [r5]
 261 002c 1A68     		ldr	r2, [r3]
 262 002e D2F80490 		ldr	r9, [r2, #4]
 263 0032 244A     		ldr	r2, .L29+8
 264 0034 2146     		mov	r1, r4
 265 0036 5868     		ldr	r0, [r3, #4]
 266 0038 C847     		blx	r9
 267              	.LVL30:
 100:Src/cortexm/stm32/stm32l4.c ****   int progress_step = progress_end/10;
 268              		.loc 1 100 0
 269 003a 0024     		movs	r4, #0
 270              	.LVL31:
 271              	.L17:
 108:Src/cortexm/stm32/stm32l4.c ****     if(priv->cortex->ops->check_error(priv->cortex->priv)) {
 272              		.loc 1 108 0
 273 003c 2B68     		ldr	r3, [r5]
 274 003e 1A68     		ldr	r2, [r3]
 275 0040 1268     		ldr	r2, [r2]
 276 0042 2149     		ldr	r1, .L29+12
 277 0044 5868     		ldr	r0, [r3, #4]
 278 0046 9047     		blx	r2
 279              	.LVL32:
 280 0048 10F4803F 		tst	r0, #65536
 281 004c 22D0     		beq	.L25
 109:Src/cortexm/stm32/stm32l4.c ****       // TODO: handle error
 282              		.loc 1 109 0
 283 004e 2B68     		ldr	r3, [r5]
 284 0050 1A68     		ldr	r2, [r3]
 285 0052 526A     		ldr	r2, [r2, #36]
 286 0054 5868     		ldr	r0, [r3, #4]
 287 0056 9047     		blx	r2
 288              	.LVL33:
 289 0058 60B9     		cbnz	r0, .L26
 114:Src/cortexm/stm32/stm32l4.c ****     time++;
 290              		.loc 1 114 0
 291 005a 0A20     		movs	r0, #10
 292 005c FFF7FEFF 		bl	osDelay
 293              	.LVL34:
 115:Src/cortexm/stm32/stm32l4.c ****     // after each 100 loops add one to progress, we asume that whole erase will take 1000 loops
 294              		.loc 1 115 0
 295 0060 0134     		adds	r4, r4, #1
 296              	.LVL35:
 117:Src/cortexm/stm32/stm32l4.c ****       time = 0;
 297              		.loc 1 117 0
 298 0062 642C     		cmp	r4, #100
 299 0064 EADD     		ble	.L17
 300              	.LVL36:
 119:Src/cortexm/stm32/stm32l4.c ****         *progress += progress_step;
 301              		.loc 1 119 0
 302 0066 D8F80010 		ldr	r1, [r8]
 303 006a BB1B     		subs	r3, r7, r6
 304 006c 9942     		cmp	r1, r3
 305 006e 09DB     		blt	.L27
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 12


 118:Src/cortexm/stm32/stm32l4.c ****       if(*progress < progress_end - progress_step) {
 306              		.loc 1 118 0
 307 0070 0024     		movs	r4, #0
 308 0072 E3E7     		b	.L17
 309              	.LVL37:
 310              	.L26:
 111:Src/cortexm/stm32/stm32l4.c ****       return STM32L4_ERASE_NEVER_END;
 311              		.loc 1 111 0
 312 0074 1548     		ldr	r0, .L29+16
 313 0076 FFF7FEFF 		bl	puts
 314              	.LVL38:
 112:Src/cortexm/stm32/stm32l4.c ****     }
 315              		.loc 1 112 0
 316 007a 4FF40064 		mov	r4, #2048
 317              	.LVL39:
 318              	.L16:
 137:Src/cortexm/stm32/stm32l4.c **** 
 319              		.loc 1 137 0
 320 007e 2046     		mov	r0, r4
 321 0080 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 322              	.LVL40:
 323              	.L27:
 120:Src/cortexm/stm32/stm32l4.c ****         printf("Flash progress %d\n", *progress);
 324              		.loc 1 120 0
 325 0084 3144     		add	r1, r1, r6
 326 0086 C8F80010 		str	r1, [r8]
 121:Src/cortexm/stm32/stm32l4.c ****       }
 327              		.loc 1 121 0
 328 008a 1148     		ldr	r0, .L29+20
 329 008c FFF7FEFF 		bl	printf
 330              	.LVL41:
 118:Src/cortexm/stm32/stm32l4.c ****       if(*progress < progress_end - progress_step) {
 331              		.loc 1 118 0
 332 0090 0024     		movs	r4, #0
 333 0092 D3E7     		b	.L17
 334              	.LVL42:
 335              	.L25:
 127:Src/cortexm/stm32/stm32l4.c ****   if ((sr & STM32L4_SR_ERROR_MASK) || !(sr & STM32L4_SR_EOP)) {
 336              		.loc 1 127 0
 337 0094 2B68     		ldr	r3, [r5]
 338 0096 1A68     		ldr	r2, [r3]
 339 0098 1268     		ldr	r2, [r2]
 340 009a 0B49     		ldr	r1, .L29+12
 341 009c 5868     		ldr	r0, [r3, #4]
 342 009e 9047     		blx	r2
 343              	.LVL43:
 344 00a0 81B2     		uxth	r1, r0
 128:Src/cortexm/stm32/stm32l4.c ****     // TODO: handle error
 345              		.loc 1 128 0
 346 00a2 00F0F300 		and	r0, r0, #243
 347              	.LVL44:
 348 00a6 0128     		cmp	r0, #1
 349 00a8 03D1     		bne	.L28
 135:Src/cortexm/stm32/stm32l4.c ****   return 0;
 350              		.loc 1 135 0
 351 00aa C8F80070 		str	r7, [r8]
 136:Src/cortexm/stm32/stm32l4.c **** }
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 13


 352              		.loc 1 136 0
 353 00ae 0024     		movs	r4, #0
 354              	.LVL45:
 355 00b0 E5E7     		b	.L16
 356              	.LVL46:
 357              	.L28:
 130:Src/cortexm/stm32/stm32l4.c ****     return sr | STM32L4_ERASE_ERROR_BIT;
 358              		.loc 1 130 0
 359 00b2 0C46     		mov	r4, r1
 360              	.LVL47:
 361 00b4 0748     		ldr	r0, .L29+24
 362 00b6 FFF7FEFF 		bl	printf
 363              	.LVL48:
 131:Src/cortexm/stm32/stm32l4.c ****   }
 364              		.loc 1 131 0
 365 00ba E0E7     		b	.L16
 366              	.L30:
 367              		.align	2
 368              	.L29:
 369 00bc 67666666 		.word	1717986919
 370 00c0 14200240 		.word	1073881108
 371 00c4 04800101 		.word	16875524
 372 00c8 10200240 		.word	1073881104
 373 00cc 00000000 		.word	.LC1
 374 00d0 24000000 		.word	.LC2
 375 00d4 38000000 		.word	.LC3
 376              		.cfi_endproc
 377              	.LFE132:
 379              		.section	.text.stm32l4_erase_flash,"ax",%progbits
 380              		.align	1
 381              		.syntax unified
 382              		.thumb
 383              		.thumb_func
 384              		.fpu fpv4-sp-d16
 386              	stm32l4_erase_flash:
 387              	.LFB134:
 148:Src/cortexm/stm32/stm32l4.c ****   uint16_t sr;
 388              		.loc 1 148 0
 389              		.cfi_startproc
 390              		@ args = 0, pretend = 0, frame = 0
 391              		@ frame_needed = 0, uses_anonymous_args = 0
 392              	.LVL49:
 393 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 394              	.LCFI4:
 395              		.cfi_def_cfa_offset 40
 396              		.cfi_offset 3, -40
 397              		.cfi_offset 4, -36
 398              		.cfi_offset 5, -32
 399              		.cfi_offset 6, -28
 400              		.cfi_offset 7, -24
 401              		.cfi_offset 8, -20
 402              		.cfi_offset 9, -16
 403              		.cfi_offset 10, -12
 404              		.cfi_offset 11, -8
 405              		.cfi_offset 14, -4
 406 0004 0446     		mov	r4, r0
 407 0006 9046     		mov	r8, r2
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 14


 408 0008 1D46     		mov	r5, r3
 151:Src/cortexm/stm32/stm32l4.c ****   int progress_step = (progress_end + 511)/512;
 409              		.loc 1 151 0
 410 000a 0846     		mov	r0, r1
 411              	.LVL50:
 412 000c FFF7FEFF 		bl	stm32l4_last_sector_to_erase
 413              	.LVL51:
 414 0010 0746     		mov	r7, r0
 415              	.LVL52:
 152:Src/cortexm/stm32/stm32l4.c **** 
 416              		.loc 1 152 0
 417 0012 05F2FF16 		addw	r6, r5, #511
 418 0016 002E     		cmp	r6, #0
 419 0018 3ADB     		blt	.L41
 420              	.L32:
 421 001a 7612     		asrs	r6, r6, #9
 422              	.LVL53:
 154:Src/cortexm/stm32/stm32l4.c ****   // TODO: For simplicity only when writing less than 64 sectors (2KB each) optimal sector erase
 423              		.loc 1 154 0
 424 001c 3048     		ldr	r0, .L45
 425 001e FFF7FEFF 		bl	puts
 426              	.LVL54:
 158:Src/cortexm/stm32/stm32l4.c ****     return stm32l4_erase_all_flash(priv, progress, progress_end);
 427              		.loc 1 158 0
 428 0022 3F2F     		cmp	r7, #63
 429 0024 37D8     		bhi	.L42
 430              	.LBB2:
 162:Src/cortexm/stm32/stm32l4.c ****     cr = STM32L4_FLASH_CR_EOPIE | STM32L4_FLASH_CR_ERRIE | STM32L4_FLASH_CR_PER;
 431              		.loc 1 162 0
 432 0026 0025     		movs	r5, #0
 433              	.LVL55:
 434              	.L33:
 162:Src/cortexm/stm32/stm32l4.c ****     cr = STM32L4_FLASH_CR_EOPIE | STM32L4_FLASH_CR_ERRIE | STM32L4_FLASH_CR_PER;
 435              		.loc 1 162 0 is_stmt 0 discriminator 1
 436 0028 ABB2     		uxth	r3, r5
 437 002a BB42     		cmp	r3, r7
 438 002c 45D8     		bhi	.L43
 439              	.LVL56:
 164:Src/cortexm/stm32/stm32l4.c ****     /* Flash page erase instruction */
 440              		.loc 1 164 0 is_stmt 1
 441 002e 4FEAC509 		lsl	r9, r5, #3
 442              	.LVL57:
 166:Src/cortexm/stm32/stm32l4.c ****     /* write address to FMA */
 443              		.loc 1 166 0
 444 0032 2368     		ldr	r3, [r4]
 445 0034 1A68     		ldr	r2, [r3]
 446 0036 D2F804B0 		ldr	fp, [r2, #4]
 447 003a DFF8BCA0 		ldr	r10, .L45+24
 448 003e 49F04072 		orr	r2, r9, #50331648
 449 0042 42F00202 		orr	r2, r2, #2
 450 0046 5146     		mov	r1, r10
 451 0048 5868     		ldr	r0, [r3, #4]
 452 004a D847     		blx	fp
 453              	.LVL58:
 168:Src/cortexm/stm32/stm32l4.c ****     /* Read FLASH_SR to poll for BSY bit */
 454              		.loc 1 168 0
 455 004c 2368     		ldr	r3, [r4]
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 15


 456 004e 1A68     		ldr	r2, [r3]
 457 0050 D2F804B0 		ldr	fp, [r2, #4]
 458 0054 234A     		ldr	r2, .L45+4
 459 0056 49EA0202 		orr	r2, r9, r2
 460 005a 5146     		mov	r1, r10
 461 005c 5868     		ldr	r0, [r3, #4]
 462 005e D847     		blx	fp
 463              	.LVL59:
 464              	.L35:
 170:Src/cortexm/stm32/stm32l4.c ****       if(priv->cortex->ops->check_error(priv->cortex->priv)) {
 465              		.loc 1 170 0
 466 0060 2368     		ldr	r3, [r4]
 467 0062 1A68     		ldr	r2, [r3]
 468 0064 1268     		ldr	r2, [r2]
 469 0066 2049     		ldr	r1, .L45+8
 470 0068 5868     		ldr	r0, [r3, #4]
 471 006a 9047     		blx	r2
 472              	.LVL60:
 473 006c 10F4803F 		tst	r0, #65536
 474 0070 18D0     		beq	.L44
 171:Src/cortexm/stm32/stm32l4.c ****         // TODO: handle error
 475              		.loc 1 171 0
 476 0072 2368     		ldr	r3, [r4]
 477 0074 1A68     		ldr	r2, [r3]
 478 0076 526A     		ldr	r2, [r2, #36]
 479 0078 5868     		ldr	r0, [r3, #4]
 480 007a 9047     		blx	r2
 481              	.LVL61:
 482 007c 0028     		cmp	r0, #0
 483 007e EFD0     		beq	.L35
 173:Src/cortexm/stm32/stm32l4.c ****         return STM32L4_ERASE_NEVER_END;
 484              		.loc 1 173 0
 485 0080 1A48     		ldr	r0, .L45+12
 486 0082 FFF7FEFF 		bl	puts
 487              	.LVL62:
 174:Src/cortexm/stm32/stm32l4.c ****       }
 488              		.loc 1 174 0
 489 0086 4FF40064 		mov	r4, #2048
 490              	.LVL63:
 491              	.L31:
 492              	.LBE2:
 190:Src/cortexm/stm32/stm32l4.c **** 
 493              		.loc 1 190 0
 494 008a 2046     		mov	r0, r4
 495 008c BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 496              	.LVL64:
 497              	.L41:
 152:Src/cortexm/stm32/stm32l4.c **** 
 498              		.loc 1 152 0
 499 0090 06F2FF16 		addw	r6, r6, #511
 500 0094 C1E7     		b	.L32
 501              	.LVL65:
 502              	.L42:
 159:Src/cortexm/stm32/stm32l4.c ****   }
 503              		.loc 1 159 0
 504 0096 2A46     		mov	r2, r5
 505 0098 4146     		mov	r1, r8
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 16


 506 009a 2046     		mov	r0, r4
 507 009c FFF7FEFF 		bl	stm32l4_erase_all_flash
 508              	.LVL66:
 509 00a0 0446     		mov	r4, r0
 510              	.LVL67:
 511 00a2 F2E7     		b	.L31
 512              	.LVL68:
 513              	.L44:
 514              	.LBB3:
 177:Src/cortexm/stm32/stm32l4.c ****     printf("Flash progress %d\n", *progress);
 515              		.loc 1 177 0 discriminator 2
 516 00a4 D8F80010 		ldr	r1, [r8]
 517 00a8 3144     		add	r1, r1, r6
 518 00aa C8F80010 		str	r1, [r8]
 178:Src/cortexm/stm32/stm32l4.c ****   }
 519              		.loc 1 178 0 discriminator 2
 520 00ae 1048     		ldr	r0, .L45+16
 521 00b0 FFF7FEFF 		bl	printf
 522              	.LVL69:
 162:Src/cortexm/stm32/stm32l4.c ****     cr = STM32L4_FLASH_CR_EOPIE | STM32L4_FLASH_CR_ERRIE | STM32L4_FLASH_CR_PER;
 523              		.loc 1 162 0 discriminator 2
 524 00b4 0135     		adds	r5, r5, #1
 525              	.LVL70:
 526 00b6 EDB2     		uxtb	r5, r5
 527              	.LVL71:
 528 00b8 B6E7     		b	.L33
 529              	.L43:
 530              	.LBE3:
 182:Src/cortexm/stm32/stm32l4.c ****   if ((sr & STM32L4_SR_ERROR_MASK) || !(sr & STM32L4_SR_EOP)) {
 531              		.loc 1 182 0
 532 00ba 2368     		ldr	r3, [r4]
 533 00bc 1A68     		ldr	r2, [r3]
 534 00be 1268     		ldr	r2, [r2]
 535 00c0 0949     		ldr	r1, .L45+8
 536 00c2 5868     		ldr	r0, [r3, #4]
 537 00c4 9047     		blx	r2
 538              	.LVL72:
 539 00c6 81B2     		uxth	r1, r0
 183:Src/cortexm/stm32/stm32l4.c ****     // TODO: handle error
 540              		.loc 1 183 0
 541 00c8 00F0F300 		and	r0, r0, #243
 542              	.LVL73:
 543 00cc 0128     		cmp	r0, #1
 544 00ce 04D0     		beq	.L39
 185:Src/cortexm/stm32/stm32l4.c ****     return sr | STM32L4_ERASE_ERROR_BIT;
 545              		.loc 1 185 0
 546 00d0 0C46     		mov	r4, r1
 547              	.LVL74:
 548 00d2 0848     		ldr	r0, .L45+20
 549 00d4 FFF7FEFF 		bl	printf
 550              	.LVL75:
 186:Src/cortexm/stm32/stm32l4.c ****   }
 551              		.loc 1 186 0
 552 00d8 D7E7     		b	.L31
 553              	.LVL76:
 554              	.L39:
 189:Src/cortexm/stm32/stm32l4.c **** }
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 17


 555              		.loc 1 189 0
 556 00da 0024     		movs	r4, #0
 557              	.LVL77:
 558 00dc D5E7     		b	.L31
 559              	.L46:
 560 00de 00BF     		.align	2
 561              	.L45:
 562 00e0 00000000 		.word	.LC4
 563 00e4 02000103 		.word	50397186
 564 00e8 10200240 		.word	1073881104
 565 00ec 00000000 		.word	.LC1
 566 00f0 24000000 		.word	.LC2
 567 00f4 38000000 		.word	.LC3
 568 00f8 14200240 		.word	1073881108
 569              		.cfi_endproc
 570              	.LFE134:
 572              		.section	.text.stm32l4_flash_write,"ax",%progbits
 573              		.align	1
 574              		.syntax unified
 575              		.thumb
 576              		.thumb_func
 577              		.fpu fpv4-sp-d16
 579              	stm32l4_flash_write:
 580              	.LFB135:
 193:Src/cortexm/stm32/stm32l4.c ****   uint32_t start_of_ram = 0x20000000;
 581              		.loc 1 193 0
 582              		.cfi_startproc
 583              		@ args = 0, pretend = 0, frame = 0
 584              		@ frame_needed = 0, uses_anonymous_args = 0
 585              	.LVL78:
 586 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 587              	.LCFI5:
 588              		.cfi_def_cfa_offset 24
 589              		.cfi_offset 3, -24
 590              		.cfi_offset 4, -20
 591              		.cfi_offset 5, -16
 592              		.cfi_offset 6, -12
 593              		.cfi_offset 7, -8
 594              		.cfi_offset 14, -4
 595 0002 0446     		mov	r4, r0
 596 0004 1746     		mov	r7, r2
 597 0006 1D46     		mov	r5, r3
 598              	.LVL79:
 199:Src/cortexm/stm32/stm32l4.c ****   *(uint32_t *)&(stm32l4_flash_write_stub[28]) = len;
 599              		.loc 1 199 0
 600 0008 234A     		ldr	r2, .L55
 601              	.LVL80:
 602 000a 5163     		str	r1, [r2, #52]
 200:Src/cortexm/stm32/stm32l4.c **** 
 603              		.loc 1 200 0
 604 000c 9363     		str	r3, [r2, #56]
 203:Src/cortexm/stm32/stm32l4.c ****   priv->cortex->ops->write_words(priv->cortex->priv, start_of_ram + stub_len, src, len);
 605              		.loc 1 203 0
 606 000e 0068     		ldr	r0, [r0]
 607              	.LVL81:
 608 0010 0368     		ldr	r3, [r0]
 609              	.LVL82:
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 18


 610 0012 DE68     		ldr	r6, [r3, #12]
 611 0014 3C23     		movs	r3, #60
 612 0016 4FF00051 		mov	r1, #536870912
 613              	.LVL83:
 614 001a 4068     		ldr	r0, [r0, #4]
 615 001c B047     		blx	r6
 616              	.LVL84:
 204:Src/cortexm/stm32/stm32l4.c ****   priv->cortex->ops->pc_write(priv->cortex->priv, start_of_ram);
 617              		.loc 1 204 0
 618 001e 2068     		ldr	r0, [r4]
 619 0020 0368     		ldr	r3, [r0]
 620 0022 DE68     		ldr	r6, [r3, #12]
 621 0024 2B46     		mov	r3, r5
 622 0026 3A46     		mov	r2, r7
 623 0028 1C49     		ldr	r1, .L55+4
 624 002a 4068     		ldr	r0, [r0, #4]
 625 002c B047     		blx	r6
 626              	.LVL85:
 205:Src/cortexm/stm32/stm32l4.c ****   if(priv->cortex->ops->check_error(priv->cortex->priv)) {
 627              		.loc 1 205 0
 628 002e 2368     		ldr	r3, [r4]
 629 0030 1A68     		ldr	r2, [r3]
 630 0032 5269     		ldr	r2, [r2, #20]
 631 0034 4FF00051 		mov	r1, #536870912
 632 0038 5868     		ldr	r0, [r3, #4]
 633 003a 9047     		blx	r2
 634              	.LVL86:
 206:Src/cortexm/stm32/stm32l4.c ****     // TODO: handle error
 635              		.loc 1 206 0
 636 003c 2368     		ldr	r3, [r4]
 637 003e 1A68     		ldr	r2, [r3]
 638 0040 526A     		ldr	r2, [r2, #36]
 639 0042 5868     		ldr	r0, [r3, #4]
 640 0044 9047     		blx	r2
 641              	.LVL87:
 642 0046 28B9     		cbnz	r0, .L53
 213:Src/cortexm/stm32/stm32l4.c ****   while(!priv->cortex->ops->halt_wait(priv->cortex->priv)) {
 643              		.loc 1 213 0
 644 0048 2368     		ldr	r3, [r4]
 645 004a 1A68     		ldr	r2, [r3]
 646 004c 126A     		ldr	r2, [r2, #32]
 647 004e 5868     		ldr	r0, [r3, #4]
 648 0050 9047     		blx	r2
 649              	.LVL88:
 214:Src/cortexm/stm32/stm32l4.c ****     // Don't be greedy about CPU, allow another task
 650              		.loc 1 214 0
 651 0052 08E0     		b	.L50
 652              	.L53:
 208:Src/cortexm/stm32/stm32l4.c ****     return STM32L4_ERROR_ON_FLASH_WRITE_SETUP;
 653              		.loc 1 208 0
 654 0054 1248     		ldr	r0, .L55+8
 655 0056 FFF7FEFF 		bl	puts
 656              	.LVL89:
 209:Src/cortexm/stm32/stm32l4.c ****   }
 657              		.loc 1 209 0
 658 005a 40F60100 		movw	r0, #2049
 659 005e 13E0     		b	.L47
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 19


 660              	.L51:
 216:Src/cortexm/stm32/stm32l4.c ****   }
 661              		.loc 1 216 0
 662 0060 0A20     		movs	r0, #10
 663 0062 FFF7FEFF 		bl	osDelay
 664              	.LVL90:
 665              	.L50:
 214:Src/cortexm/stm32/stm32l4.c ****     // Don't be greedy about CPU, allow another task
 666              		.loc 1 214 0
 667 0066 2368     		ldr	r3, [r4]
 668 0068 1A68     		ldr	r2, [r3]
 669 006a D269     		ldr	r2, [r2, #28]
 670 006c 5868     		ldr	r0, [r3, #4]
 671 006e 9047     		blx	r2
 672              	.LVL91:
 673 0070 0028     		cmp	r0, #0
 674 0072 F5D0     		beq	.L51
 220:Src/cortexm/stm32/stm32l4.c ****   if (sr & STM32L4_SR_ERROR_MASK) {
 675              		.loc 1 220 0
 676 0074 2368     		ldr	r3, [r4]
 677 0076 1A68     		ldr	r2, [r3]
 678 0078 1268     		ldr	r2, [r2]
 679 007a 0A49     		ldr	r1, .L55+12
 680 007c 5868     		ldr	r0, [r3, #4]
 681 007e 9047     		blx	r2
 682              	.LVL92:
 683 0080 84B2     		uxth	r4, r0
 684              	.LVL93:
 221:Src/cortexm/stm32/stm32l4.c ****     // TODO: handle error
 685              		.loc 1 221 0
 686 0082 14F0F200 		ands	r0, r4, #242
 687 0086 00D1     		bne	.L54
 688              	.LVL94:
 689              	.L47:
 228:Src/cortexm/stm32/stm32l4.c **** 
 690              		.loc 1 228 0
 691 0088 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 692              	.LVL95:
 693              	.L54:
 223:Src/cortexm/stm32/stm32l4.c ****     return sr | STM32L4_FLASH_ERROR_BIT;
 694              		.loc 1 223 0
 695 008a 2146     		mov	r1, r4
 696 008c 0648     		ldr	r0, .L55+16
 697 008e FFF7FEFF 		bl	printf
 698              	.LVL96:
 224:Src/cortexm/stm32/stm32l4.c ****   }
 699              		.loc 1 224 0
 700 0092 44F48060 		orr	r0, r4, #1024
 701 0096 F7E7     		b	.L47
 702              	.L56:
 703              		.align	2
 704              	.L55:
 705 0098 00000000 		.word	.LANCHOR0
 706 009c 3C000020 		.word	536870972
 707 00a0 00000000 		.word	.LC5
 708 00a4 10200240 		.word	1073881104
 709 00a8 28000000 		.word	.LC6
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 20


 710              		.cfi_endproc
 711              	.LFE135:
 713              		.section	.text.stm32l4_program,"ax",%progbits
 714              		.align	1
 715              		.syntax unified
 716              		.thumb
 717              		.thumb_func
 718              		.fpu fpv4-sp-d16
 720              	stm32l4_program:
 721              	.LFB136:
 231:Src/cortexm/stm32/stm32l4.c ****   UINT br;
 722              		.loc 1 231 0
 723              		.cfi_startproc
 724              		@ args = 0, pretend = 0, frame = 8
 725              		@ frame_needed = 0, uses_anonymous_args = 0
 726              	.LVL97:
 727 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 728              	.LCFI6:
 729              		.cfi_def_cfa_offset 28
 730              		.cfi_offset 4, -28
 731              		.cfi_offset 5, -24
 732              		.cfi_offset 6, -20
 733              		.cfi_offset 7, -16
 734              		.cfi_offset 8, -12
 735              		.cfi_offset 9, -8
 736              		.cfi_offset 14, -4
 737 0004 2DED028B 		vpush.64	{d8}
 738              	.LCFI7:
 739              		.cfi_def_cfa_offset 36
 740              		.cfi_offset 80, -36
 741              		.cfi_offset 81, -32
 742 0008 83B0     		sub	sp, sp, #12
 743              	.LCFI8:
 744              		.cfi_def_cfa_offset 48
 745 000a 0646     		mov	r6, r0
 746 000c 8846     		mov	r8, r1
 747 000e 1746     		mov	r7, r2
 748              	.LVL98:
 235:Src/cortexm/stm32/stm32l4.c ****   STM32L4_PRIV_t *priv = priv_void;
 749              		.loc 1 235 0
 750 0010 4FF48050 		mov	r0, #4096
 751              	.LVL99:
 752 0014 FFF7FEFF 		bl	pvPortMalloc
 753              	.LVL100:
 754 0018 0546     		mov	r5, r0
 755              	.LVL101:
 238:Src/cortexm/stm32/stm32l4.c **** 
 756              		.loc 1 238 0
 757 001a D8F80C90 		ldr	r9, [r8, #12]
 758              	.LVL102:
 241:Src/cortexm/stm32/stm32l4.c ****   float progress_as_float = 100 * STM32L4_ERASE_TIME_IN_WRITES/(number_of_writes + STM32L4_ERASE_TI
 759              		.loc 1 241 0
 760 001e 09F6FF73 		addw	r3, r9, #4095
 761 0022 1C0B     		lsrs	r4, r3, #12
 762              	.LVL103:
 242:Src/cortexm/stm32/stm32l4.c ****   float progress_on_one_write;
 763              		.loc 1 242 0
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 21


 764 0024 04F10A02 		add	r2, r4, #10
 765 0028 4FF47A73 		mov	r3, #1000
 766 002c 93FBF2F3 		sdiv	r3, r3, r2
 767 0030 07EE903A 		vmov	s15, r3	@ int
 768 0034 B8EEE78A 		vcvt.f32.s32	s16, s15
 769              	.LVL104:
 245:Src/cortexm/stm32/stm32l4.c **** 
 770              		.loc 1 245 0
 771 0038 4648     		ldr	r0, .L68
 772              	.LVL105:
 773 003a FFF7FEFF 		bl	puts
 774              	.LVL106:
 247:Src/cortexm/stm32/stm32l4.c ****   stm32l4_flash_unlock(priv);
 775              		.loc 1 247 0
 776 003e 3368     		ldr	r3, [r6]
 777 0040 1A68     		ldr	r2, [r3]
 778 0042 9269     		ldr	r2, [r2, #24]
 779 0044 5868     		ldr	r0, [r3, #4]
 780 0046 9047     		blx	r2
 781              	.LVL107:
 248:Src/cortexm/stm32/stm32l4.c ****   result = stm32l4_erase_flash(priv, file_len, progress, progress_as_float);
 782              		.loc 1 248 0
 783 0048 3046     		mov	r0, r6
 784 004a FFF7FEFF 		bl	stm32l4_flash_unlock
 785              	.LVL108:
 249:Src/cortexm/stm32/stm32l4.c ****   if(result) {
 786              		.loc 1 249 0
 787 004e FDEEC87A 		vcvt.s32.f32	s15, s16
 788 0052 17EE903A 		vmov	r3, s15	@ int
 789 0056 3A46     		mov	r2, r7
 790 0058 4946     		mov	r1, r9
 791 005a 3046     		mov	r0, r6
 792 005c FFF7FEFF 		bl	stm32l4_erase_flash
 793              	.LVL109:
 794 0060 83B2     		uxth	r3, r0
 795              	.LVL110:
 250:Src/cortexm/stm32/stm32l4.c ****     vPortFree(data);
 796              		.loc 1 250 0
 797 0062 002B     		cmp	r3, #0
 798 0064 4BD1     		bne	.L65
 255:Src/cortexm/stm32/stm32l4.c ****   progress_on_one_write = (100 - *progress)/number_of_writes;
 799              		.loc 1 255 0
 800 0066 D7ED007A 		vldr.32	s15, [r7]	@ int
 801 006a B8EEE78A 		vcvt.f32.s32	s16, s15
 802              	.LVL111:
 256:Src/cortexm/stm32/stm32l4.c **** 
 803              		.loc 1 256 0
 804 006e 17EE903A 		vmov	r3, s15	@ int
 805              	.LVL112:
 806 0072 C3F16403 		rsb	r3, r3, #100
 807 0076 93FBF4F3 		sdiv	r3, r3, r4
 808 007a 07EE903A 		vmov	s15, r3	@ int
 809 007e F8EEE78A 		vcvt.f32.s32	s17, s15
 810              	.LVL113:
 234:Src/cortexm/stm32/stm32l4.c ****   uint32_t *data = pvPortMalloc(STM32L4_SIZE_OF_ONE_WRITE);
 811              		.loc 1 234 0
 812 0082 4FF00064 		mov	r4, #134217728
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 22


 813              	.LVL114:
 814              	.L63:
 259:Src/cortexm/stm32/stm32l4.c ****     printf("flash 0x%x bytes on 0x%lx\n", br, addr);
 815              		.loc 1 259 0
 816 0086 01AB     		add	r3, sp, #4
 817 0088 4FF48052 		mov	r2, #4096
 818 008c 2946     		mov	r1, r5
 819 008e 4046     		mov	r0, r8
 820 0090 FFF7FEFF 		bl	f_read
 821              	.LVL115:
 260:Src/cortexm/stm32/stm32l4.c ****     unaligned = br & 0x3;
 822              		.loc 1 260 0
 823 0094 2246     		mov	r2, r4
 824 0096 0199     		ldr	r1, [sp, #4]
 825 0098 2F48     		ldr	r0, .L68+4
 826 009a FFF7FEFF 		bl	printf
 827              	.LVL116:
 261:Src/cortexm/stm32/stm32l4.c ****     if (unaligned) {
 828              		.loc 1 261 0
 829 009e 019B     		ldr	r3, [sp, #4]
 830              	.LVL117:
 262:Src/cortexm/stm32/stm32l4.c ****       // If number of readed bytes % sizeof(uint32_t) != 0, last readed bytes are unaligned.
 831              		.loc 1 262 0
 832 00a0 13F00302 		ands	r2, r3, #3
 833 00a4 32D1     		bne	.L66
 280:Src/cortexm/stm32/stm32l4.c ****     if(result) {
 834              		.loc 1 280 0
 835 00a6 2A46     		mov	r2, r5
 836 00a8 2146     		mov	r1, r4
 837 00aa 3046     		mov	r0, r6
 838 00ac FFF7FEFF 		bl	stm32l4_flash_write
 839              	.LVL118:
 840 00b0 80B2     		uxth	r0, r0
 841              	.LVL119:
 281:Src/cortexm/stm32/stm32l4.c ****       vPortFree(data);
 842              		.loc 1 281 0
 843 00b2 0028     		cmp	r0, #0
 844 00b4 49D1     		bne	.L67
 285:Src/cortexm/stm32/stm32l4.c **** 
 845              		.loc 1 285 0
 846 00b6 019B     		ldr	r3, [sp, #4]
 847 00b8 1C44     		add	r4, r4, r3
 848              	.LVL120:
 287:Src/cortexm/stm32/stm32l4.c ****     *progress = (int)progress_as_float;
 849              		.loc 1 287 0
 850 00ba 38EE288A 		vadd.f32	s16, s16, s17
 851              	.LVL121:
 288:Src/cortexm/stm32/stm32l4.c ****     printf("Flash progress %d\n", *progress);
 852              		.loc 1 288 0
 853 00be FDEEC87A 		vcvt.s32.f32	s15, s16
 854 00c2 17EE901A 		vmov	r1, s15	@ int
 855 00c6 C7ED007A 		vstr.32	s15, [r7]	@ int
 289:Src/cortexm/stm32/stm32l4.c **** 
 856              		.loc 1 289 0
 857 00ca 2448     		ldr	r0, .L68+8
 858              	.LVL122:
 859 00cc FFF7FEFF 		bl	printf
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 23


 860              	.LVL123:
 292:Src/cortexm/stm32/stm32l4.c **** 
 861              		.loc 1 292 0
 862 00d0 019B     		ldr	r3, [sp, #4]
 863 00d2 B3F5805F 		cmp	r3, #4096
 864 00d6 D6D0     		beq	.L63
 865              	.LVL124:
 866              	.L61:
 294:Src/cortexm/stm32/stm32l4.c **** 
 867              		.loc 1 294 0
 868 00d8 2846     		mov	r0, r5
 869 00da FFF7FEFF 		bl	vPortFree
 870              	.LVL125:
 296:Src/cortexm/stm32/stm32l4.c ****   priv->cortex->ops->restart(priv->cortex->priv);
 871              		.loc 1 296 0
 872 00de 2048     		ldr	r0, .L68+12
 873 00e0 FFF7FEFF 		bl	puts
 874              	.LVL126:
 297:Src/cortexm/stm32/stm32l4.c **** 
 875              		.loc 1 297 0
 876 00e4 3368     		ldr	r3, [r6]
 877 00e6 1A68     		ldr	r2, [r3]
 878 00e8 926A     		ldr	r2, [r2, #40]
 879 00ea 5868     		ldr	r0, [r3, #4]
 880 00ec 9047     		blx	r2
 881              	.LVL127:
 299:Src/cortexm/stm32/stm32l4.c ****   return 0;
 882              		.loc 1 299 0
 883 00ee 6423     		movs	r3, #100
 884 00f0 3B60     		str	r3, [r7]
 300:Src/cortexm/stm32/stm32l4.c **** }
 885              		.loc 1 300 0
 886 00f2 0020     		movs	r0, #0
 887              	.LVL128:
 888              	.L57:
 301:Src/cortexm/stm32/stm32l4.c **** 
 889              		.loc 1 301 0
 890 00f4 03B0     		add	sp, sp, #12
 891              	.LCFI9:
 892              		.cfi_remember_state
 893              		.cfi_def_cfa_offset 36
 894              		@ sp needed
 895 00f6 BDEC028B 		vldm	sp!, {d8}
 896              	.LCFI10:
 897              		.cfi_restore 80
 898              		.cfi_restore 81
 899              		.cfi_def_cfa_offset 28
 900              	.LVL129:
 901 00fa BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 902              	.LVL130:
 903              	.L65:
 904              	.LCFI11:
 905              		.cfi_restore_state
 906 00fe 8146     		mov	r9, r0
 907              	.LVL131:
 251:Src/cortexm/stm32/stm32l4.c ****     return result;
 908              		.loc 1 251 0
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 24


 909 0100 2846     		mov	r0, r5
 910 0102 FFF7FEFF 		bl	vPortFree
 911              	.LVL132:
 912 0106 1FFA89F0 		uxth	r0, r9
 252:Src/cortexm/stm32/stm32l4.c ****   }
 913              		.loc 1 252 0
 914 010a F3E7     		b	.L57
 915              	.LVL133:
 916              	.L66:
 266:Src/cortexm/stm32/stm32l4.c ****       data[br] |= ((~0) >> (unaligned << 0x3));
 917              		.loc 1 266 0
 918 010c 9B08     		lsrs	r3, r3, #2
 919              	.LVL134:
 920 010e 0193     		str	r3, [sp, #4]
 921              	.LVL135:
 267:Src/cortexm/stm32/stm32l4.c ****       // add modified bytes to bytes that will be written
 922              		.loc 1 267 0
 923 0110 D200     		lsls	r2, r2, #3
 924 0112 4FF0FF31 		mov	r1, #-1
 925 0116 41FA02F2 		asr	r2, r1, r2
 926 011a 55F82310 		ldr	r1, [r5, r3, lsl #2]
 927 011e 1143     		orrs	r1, r1, r2
 928 0120 45F82310 		str	r1, [r5, r3, lsl #2]
 269:Src/cortexm/stm32/stm32l4.c ****       br <<= 2;
 929              		.loc 1 269 0
 930 0124 019B     		ldr	r3, [sp, #4]
 931 0126 0133     		adds	r3, r3, #1
 270:Src/cortexm/stm32/stm32l4.c ****       result = stm32l4_flash_write(priv, addr, data, br);
 932              		.loc 1 270 0
 933 0128 9B00     		lsls	r3, r3, #2
 934 012a 0193     		str	r3, [sp, #4]
 271:Src/cortexm/stm32/stm32l4.c ****       if(result) {
 935              		.loc 1 271 0
 936 012c 2A46     		mov	r2, r5
 937 012e 2146     		mov	r1, r4
 938 0130 3046     		mov	r0, r6
 939 0132 FFF7FEFF 		bl	stm32l4_flash_write
 940              	.LVL136:
 941 0136 8146     		mov	r9, r0
 942              	.LVL137:
 943 0138 83B2     		uxth	r3, r0
 944              	.LVL138:
 272:Src/cortexm/stm32/stm32l4.c ****         vPortFree(data);
 945              		.loc 1 272 0
 946 013a 002B     		cmp	r3, #0
 947 013c CCD0     		beq	.L61
 273:Src/cortexm/stm32/stm32l4.c ****         return result;
 948              		.loc 1 273 0
 949 013e 2846     		mov	r0, r5
 950 0140 FFF7FEFF 		bl	vPortFree
 951              	.LVL139:
 952 0144 1FFA89F0 		uxth	r0, r9
 274:Src/cortexm/stm32/stm32l4.c ****       }
 953              		.loc 1 274 0
 954 0148 D4E7     		b	.L57
 955              	.LVL140:
 956              	.L67:
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 25


 282:Src/cortexm/stm32/stm32l4.c ****       return 1;
 957              		.loc 1 282 0
 958 014a 2846     		mov	r0, r5
 959              	.LVL141:
 960 014c FFF7FEFF 		bl	vPortFree
 961              	.LVL142:
 283:Src/cortexm/stm32/stm32l4.c ****     }
 962              		.loc 1 283 0
 963 0150 0120     		movs	r0, #1
 964 0152 CFE7     		b	.L57
 965              	.L69:
 966              		.align	2
 967              	.L68:
 968 0154 00000000 		.word	.LC7
 969 0158 18000000 		.word	.LC8
 970 015c 24000000 		.word	.LC2
 971 0160 34000000 		.word	.LC9
 972              		.cfi_endproc
 973              	.LFE136:
 975              		.section	.text.stm32l4_probe,"ax",%progbits
 976              		.align	1
 977              		.global	stm32l4_probe
 978              		.syntax unified
 979              		.thumb
 980              		.thumb_func
 981              		.fpu fpv4-sp-d16
 983              	stm32l4_probe:
 984              	.LFB139:
 312:Src/cortexm/stm32/stm32l4.c **** 
 313:Src/cortexm/stm32/stm32l4.c **** static TARGET_OPS_t stm32l4_ops = {
 314:Src/cortexm/stm32/stm32l4.c ****   .flash_target = stm32l4_program,
 315:Src/cortexm/stm32/stm32l4.c ****   .reset_target = stm32l4_restart,
 316:Src/cortexm/stm32/stm32l4.c **** 
 317:Src/cortexm/stm32/stm32l4.c ****   .free_priv = stm32l4_free_priv
 318:Src/cortexm/stm32/stm32l4.c **** };
 319:Src/cortexm/stm32/stm32l4.c **** 
 320:Src/cortexm/stm32/stm32l4.c **** static char stm32l4_name[] = "STM32L4x";
 321:Src/cortexm/stm32/stm32l4.c **** 
 322:Src/cortexm/stm32/stm32l4.c **** int stm32l4_probe(CORTEXM_t *cortexm)
 323:Src/cortexm/stm32/stm32l4.c **** {
 985              		.loc 1 323 0
 986              		.cfi_startproc
 987              		@ args = 0, pretend = 0, frame = 0
 988              		@ frame_needed = 0, uses_anonymous_args = 0
 989              	.LVL143:
 990 0000 38B5     		push	{r3, r4, r5, lr}
 991              	.LCFI12:
 992              		.cfi_def_cfa_offset 16
 993              		.cfi_offset 3, -16
 994              		.cfi_offset 4, -12
 995              		.cfi_offset 5, -8
 996              		.cfi_offset 14, -4
 997 0002 0546     		mov	r5, r0
 324:Src/cortexm/stm32/stm32l4.c ****   uint32_t idcode;
 325:Src/cortexm/stm32/stm32l4.c ****   STM32L4_PRIV_t *priv;
 326:Src/cortexm/stm32/stm32l4.c **** 
 327:Src/cortexm/stm32/stm32l4.c ****   idcode = cortexm->ops->read_word(cortexm->priv, STM32L4_DBGMCU_IDCODE);
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 26


 998              		.loc 1 327 0
 999 0004 0368     		ldr	r3, [r0]
 1000 0006 1B68     		ldr	r3, [r3]
 1001 0008 1149     		ldr	r1, .L76
 1002 000a 4068     		ldr	r0, [r0, #4]
 1003              	.LVL144:
 1004 000c 9847     		blx	r3
 1005              	.LVL145:
 1006 000e 0446     		mov	r4, r0
 1007              	.LVL146:
 328:Src/cortexm/stm32/stm32l4.c ****   printf("STM32L4 probed id code: 0x%lx\n", idcode);
 1008              		.loc 1 328 0
 1009 0010 0146     		mov	r1, r0
 1010 0012 1048     		ldr	r0, .L76+4
 1011              	.LVL147:
 1012 0014 FFF7FEFF 		bl	printf
 1013              	.LVL148:
 329:Src/cortexm/stm32/stm32l4.c **** 
 330:Src/cortexm/stm32/stm32l4.c ****   switch (idcode & 0xFFF) {
 1014              		.loc 1 330 0
 1015 0018 C4F30B00 		ubfx	r0, r4, #0, #12
 1016 001c 40F23543 		movw	r3, #1077
 1017 0020 9842     		cmp	r0, r3
 1018 0022 0AD0     		beq	.L72
 1019 0024 05D8     		bhi	.L73
 1020 0026 40F21543 		movw	r3, #1045
 1021 002a 9842     		cmp	r0, r3
 1022 002c 05D0     		beq	.L72
 1023              	.L74:
 331:Src/cortexm/stm32/stm32l4.c ****     case 0x461: /* L496/RM0351 */
 332:Src/cortexm/stm32/stm32l4.c ****     case 0x415: /* L471/RM0392, L475/RM0395, L476/RM0351 */
 333:Src/cortexm/stm32/stm32l4.c ****     case 0x462: /* L45x L46x / RM0394  */
 334:Src/cortexm/stm32/stm32l4.c ****     case 0x435: /* L43x L44x / RM0394  */
 335:Src/cortexm/stm32/stm32l4.c ****       priv = pvPortMalloc(sizeof(STM32L4_PRIV_t));
 336:Src/cortexm/stm32/stm32l4.c ****       priv->cortex = cortexm;
 337:Src/cortexm/stm32/stm32l4.c ****       register_target(priv, &stm32l4_ops, stm32l4_name);
 338:Src/cortexm/stm32/stm32l4.c ****       return 1;
 339:Src/cortexm/stm32/stm32l4.c ****   }
 340:Src/cortexm/stm32/stm32l4.c **** 
 341:Src/cortexm/stm32/stm32l4.c ****   return 0;
 1024              		.loc 1 341 0
 1025 002e 0020     		movs	r0, #0
 1026              	.L70:
 342:Src/cortexm/stm32/stm32l4.c **** }
 1027              		.loc 1 342 0
 1028 0030 38BD     		pop	{r3, r4, r5, pc}
 1029              	.LVL149:
 1030              	.L73:
 330:Src/cortexm/stm32/stm32l4.c ****     case 0x461: /* L496/RM0351 */
 1031              		.loc 1 330 0
 1032 0032 A0F26140 		subw	r0, r0, #1121
 1033 0036 0128     		cmp	r0, #1
 1034 0038 F9D8     		bhi	.L74
 1035              	.L72:
 335:Src/cortexm/stm32/stm32l4.c ****       priv->cortex = cortexm;
 1036              		.loc 1 335 0
 1037 003a 0420     		movs	r0, #4
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 27


 1038 003c FFF7FEFF 		bl	pvPortMalloc
 1039              	.LVL150:
 336:Src/cortexm/stm32/stm32l4.c ****       register_target(priv, &stm32l4_ops, stm32l4_name);
 1040              		.loc 1 336 0
 1041 0040 0560     		str	r5, [r0]
 337:Src/cortexm/stm32/stm32l4.c ****       return 1;
 1042              		.loc 1 337 0
 1043 0042 054A     		ldr	r2, .L76+8
 1044 0044 0549     		ldr	r1, .L76+12
 1045 0046 FFF7FEFF 		bl	register_target
 1046              	.LVL151:
 338:Src/cortexm/stm32/stm32l4.c ****   }
 1047              		.loc 1 338 0
 1048 004a 0120     		movs	r0, #1
 1049 004c F0E7     		b	.L70
 1050              	.L77:
 1051 004e 00BF     		.align	2
 1052              	.L76:
 1053 0050 002004E0 		.word	-536600576
 1054 0054 00000000 		.word	.LC10
 1055 0058 00000000 		.word	.LANCHOR1
 1056 005c 00000000 		.word	.LANCHOR2
 1057              		.cfi_endproc
 1058              	.LFE139:
 1060              		.section	.data.stm32l4_flash_write_stub,"aw",%progbits
 1061              		.align	2
 1062              		.set	.LANCHOR0,. + 0
 1065              	stm32l4_flash_write_stub:
 1066 0000 DFF8     		.short	-1825
 1067 0002 2C00     		.short	44
 1068 0004 0B49     		.short	18699
 1069 0006 0DA2     		.short	-24051
 1070 0008 0B4B     		.short	19211
 1071 000a 084D     		.short	19720
 1072 000c 6BB1     		.short	-20117
 1073 000e 4561     		.short	24901
 1074 0010 1468     		.short	26644
 1075 0012 0C60     		.short	24588
 1076 0014 0469     		.short	26884
 1077 0016 16F4     		.short	-3050
 1078 0018 803F     		.short	16256
 1079 001a FBD1     		.short	-11781
 1080 001c 16F0     		.short	-4074
 1081 001e FA0F     		.short	4090
 1082 0020 03D1     		.short	-12029
 1083 0022 043B     		.short	15108
 1084 0024 0431     		.short	12548
 1085 0026 0432     		.short	12804
 1086 0028 F0E7     		.short	-6160
 1087 002a 00BE     		.short	-16896
 1088 002c 0100     		.short	1
 1089 002e 0000     		.short	0
 1090 0030 0020     		.short	8192
 1091 0032 0240     		.short	16386
 1092 0034 0000     		.short	0
 1093 0036 0000     		.short	0
 1094 0038 0000     		.short	0
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 28


 1095 003a 0000     		.short	0
 1096              		.section	.data.stm32l4_name,"aw",%progbits
 1097              		.align	2
 1098              		.set	.LANCHOR1,. + 0
 1101              	stm32l4_name:
 1102 0000 53544D33 		.ascii	"STM32L4x\000"
 1102      324C3478 
 1102      00
 1103              		.section	.data.stm32l4_ops,"aw",%progbits
 1104              		.align	2
 1105              		.set	.LANCHOR2,. + 0
 1108              	stm32l4_ops:
 1109 0000 00000000 		.word	stm32l4_program
 1110 0004 00000000 		.word	stm32l4_restart
 1111 0008 00000000 		.word	stm32l4_free_priv
 1112              		.section	.rodata.stm32l4_erase_all_flash.str1.4,"aMS",%progbits,1
 1113              		.align	2
 1114              	.LC1:
 1115 0000 4572726F 		.ascii	"Error while waiting for erase end\000"
 1115      72207768 
 1115      696C6520 
 1115      77616974 
 1115      696E6720 
 1116 0022 0000     		.space	2
 1117              	.LC2:
 1118 0024 466C6173 		.ascii	"Flash progress %d\012\000"
 1118      68207072 
 1118      6F677265 
 1118      73732025 
 1118      640A00
 1119 0037 00       		.space	1
 1120              	.LC3:
 1121 0038 4572726F 		.ascii	"Error after erase 0x%x\012\000"
 1121      72206166 
 1121      74657220 
 1121      65726173 
 1121      65203078 
 1122              		.section	.rodata.stm32l4_erase_flash.str1.4,"aMS",%progbits,1
 1123              		.align	2
 1124              	.LC4:
 1125 0000 45726173 		.ascii	"Erase Flash\000"
 1125      6520466C 
 1125      61736800 
 1126              		.section	.rodata.stm32l4_flash_unlock.str1.4,"aMS",%progbits,1
 1127              		.align	2
 1128              	.LC0:
 1129 0000 466C6173 		.ascii	"Flash unlock\000"
 1129      6820756E 
 1129      6C6F636B 
 1129      00
 1130              		.section	.rodata.stm32l4_flash_write.str1.4,"aMS",%progbits,1
 1131              		.align	2
 1132              	.LC5:
 1133 0000 4552524F 		.ascii	"ERROR: Filed to setup write operation\000"
 1133      523A2046 
 1133      696C6564 
 1133      20746F20 
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 29


 1133      73657475 
 1134 0026 0000     		.space	2
 1135              	.LC6:
 1136 0028 4552524F 		.ascii	"ERROR: writing ended with error 0x%x\012\000"
 1136      523A2077 
 1136      72697469 
 1136      6E672065 
 1136      6E646564 
 1137              		.section	.rodata.stm32l4_probe.str1.4,"aMS",%progbits,1
 1138              		.align	2
 1139              	.LC10:
 1140 0000 53544D33 		.ascii	"STM32L4 probed id code: 0x%lx\012\000"
 1140      324C3420 
 1140      70726F62 
 1140      65642069 
 1140      6420636F 
 1141              		.section	.rodata.stm32l4_program.str1.4,"aMS",%progbits,1
 1142              		.align	2
 1143              	.LC7:
 1144 0000 53746172 		.ascii	"Start flashing STM32L4x\000"
 1144      7420666C 
 1144      61736869 
 1144      6E672053 
 1144      544D3332 
 1145              	.LC8:
 1146 0018 666C6173 		.ascii	"flash 0x%x bytes on 0x%lx\012\000"
 1146      68203078 
 1146      25782062 
 1146      79746573 
 1146      206F6E20 
 1147 0033 00       		.space	1
 1148              	.LC9:
 1149 0034 44657669 		.ascii	"Device flashed\012Reset device\000"
 1149      63652066 
 1149      6C617368 
 1149      65640A52 
 1149      65736574 
 1150              		.text
 1151              	.Letext0:
 1152              		.file 2 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_defau
 1153              		.file 3 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 1154              		.file 4 "Drivers/CMSIS/Include/core_cm4.h"
 1155              		.file 5 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/system_stm32f4xx.h"
 1156              		.file 6 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 1157              		.file 7 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 1158              		.file 8 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/
 1159              		.file 9 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 1160              		.file 10 "Middlewares/Third_Party/FreeRTOS/Source/include/task.h"
 1161              		.file 11 "Middlewares/Third_Party/FreeRTOS/Source/include/queue.h"
 1162              		.file 12 "Middlewares/Third_Party/FreeRTOS/Source/include/semphr.h"
 1163              		.file 13 "Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS/cmsis_os.h"
 1164              		.file 14 "Inc/cortexm/cortexm.h"
 1165              		.file 15 "Inc/cortexm/stm32/stm32l4.h"
 1166              		.file 16 "Middlewares/Third_Party/FatFs/src/integer.h"
 1167              		.file 17 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/stdlib.h"
 1168              		.file 18 "Middlewares/ST/STM32_USB_Host_Library/Core/Inc/usbh_def.h"
 1169              		.file 19 "Middlewares/ST/STM32_USB_Host_Library/Core/Inc/usbh_ctlreq.h"
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 30


 1170              		.file 20 "Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc/usbh_msc.h"
 1171              		.file 21 "Middlewares/Third_Party/FatFs/src/ff.h"
 1172              		.file 22 "Middlewares/Third_Party/FatFs/src/diskio.h"
 1173              		.file 23 "Middlewares/Third_Party/FatFs/src/ff_gen_drv.h"
 1174              		.file 24 "Inc/usbh_diskio.h"
 1175              		.file 25 "Inc/fatfs.h"
 1176              		.file 26 "Inc/target.h"
 1177              		.file 27 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/stdio.h"
 1178              		.file 28 "Middlewares/Third_Party/FreeRTOS/Source/include/portable.h"
 1179              		.file 29 "<built-in>"
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s 			page 31


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32l4.c
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:18     .text.stm32l4_last_sector_to_erase:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:24     .text.stm32l4_last_sector_to_erase:0000000000000000 stm32l4_last_sector_to_erase
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:63     .text.stm32l4_restart:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:69     .text.stm32l4_restart:0000000000000000 stm32l4_restart
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:95     .text.stm32l4_free_priv:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:101    .text.stm32l4_free_priv:0000000000000000 stm32l4_free_priv
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:131    .text.stm32l4_flash_unlock:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:137    .text.stm32l4_flash_unlock:0000000000000000 stm32l4_flash_unlock
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:202    .text.stm32l4_flash_unlock:000000000000004c $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:212    .text.stm32l4_erase_all_flash:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:218    .text.stm32l4_erase_all_flash:0000000000000000 stm32l4_erase_all_flash
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:369    .text.stm32l4_erase_all_flash:00000000000000bc $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:380    .text.stm32l4_erase_flash:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:386    .text.stm32l4_erase_flash:0000000000000000 stm32l4_erase_flash
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:562    .text.stm32l4_erase_flash:00000000000000e0 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:573    .text.stm32l4_flash_write:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:579    .text.stm32l4_flash_write:0000000000000000 stm32l4_flash_write
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:705    .text.stm32l4_flash_write:0000000000000098 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:714    .text.stm32l4_program:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:720    .text.stm32l4_program:0000000000000000 stm32l4_program
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:968    .text.stm32l4_program:0000000000000154 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:976    .text.stm32l4_probe:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:983    .text.stm32l4_probe:0000000000000000 stm32l4_probe
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:1053   .text.stm32l4_probe:0000000000000050 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:1061   .data.stm32l4_flash_write_stub:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:1065   .data.stm32l4_flash_write_stub:0000000000000000 stm32l4_flash_write_stub
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:1097   .data.stm32l4_name:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:1101   .data.stm32l4_name:0000000000000000 stm32l4_name
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:1104   .data.stm32l4_ops:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:1108   .data.stm32l4_ops:0000000000000000 stm32l4_ops
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:1113   .rodata.stm32l4_erase_all_flash.str1.4:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:1123   .rodata.stm32l4_erase_flash.str1.4:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:1127   .rodata.stm32l4_flash_unlock.str1.4:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:1131   .rodata.stm32l4_flash_write.str1.4:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:1138   .rodata.stm32l4_probe.str1.4:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccuIL0EG.s:1142   .rodata.stm32l4_program.str1.4:0000000000000000 $d

UNDEFINED SYMBOLS
vPortFree
puts
osDelay
printf
pvPortMalloc
f_read
register_target
