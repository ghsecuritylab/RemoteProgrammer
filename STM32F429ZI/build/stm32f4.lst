ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"stm32f4.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.stm32f4_sectors_in_bank1,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu fpv4-sp-d16
  24              	stm32f4_sectors_in_bank1:
  25              	.LFB133:
  26              		.file 1 "Src/cortexm/stm32/stm32f4.c"
   1:Src/cortexm/stm32/stm32f4.c **** /*
   2:Src/cortexm/stm32/stm32f4.c ****  * This file is part of the Black Magic Debug project.
   3:Src/cortexm/stm32/stm32f4.c ****  *
   4:Src/cortexm/stm32/stm32f4.c ****  * Copyright (C) 2011  Black Sphere Technologies Ltd.
   5:Src/cortexm/stm32/stm32f4.c ****  * Written by Gareth McMullin <gareth@blacksphere.co.nz>
   6:Src/cortexm/stm32/stm32f4.c ****  *
   7:Src/cortexm/stm32/stm32f4.c ****  * Copyright (C) 2018  Tomasz Michalec <tomasz.michalec1996@gmail.com>
   8:Src/cortexm/stm32/stm32f4.c ****  *
   9:Src/cortexm/stm32/stm32f4.c ****  * This program is free software: you can redistribute it and/or modify
  10:Src/cortexm/stm32/stm32f4.c ****  * it under the terms of the GNU General Public License as published by
  11:Src/cortexm/stm32/stm32f4.c ****  * the Free Software Foundation, either version 3 of the License, or
  12:Src/cortexm/stm32/stm32f4.c ****  * (at your option) any later version.
  13:Src/cortexm/stm32/stm32f4.c ****  *
  14:Src/cortexm/stm32/stm32f4.c ****  * This program is distributed in the hope that it will be useful,
  15:Src/cortexm/stm32/stm32f4.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:Src/cortexm/stm32/stm32f4.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:Src/cortexm/stm32/stm32f4.c ****  * GNU General Public License for more details.
  18:Src/cortexm/stm32/stm32f4.c ****  *
  19:Src/cortexm/stm32/stm32f4.c ****  * You should have received a copy of the GNU General Public License
  20:Src/cortexm/stm32/stm32f4.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:Src/cortexm/stm32/stm32f4.c ****  */
  22:Src/cortexm/stm32/stm32f4.c **** 
  23:Src/cortexm/stm32/stm32f4.c **** /*
  24:Src/cortexm/stm32/stm32f4.c ****  * What has been modified by Tomasz Michalec:
  25:Src/cortexm/stm32/stm32f4.c ****  *   -- Fucntions use new API defined in this project
  26:Src/cortexm/stm32/stm32f4.c ****  *   -- Use FreeRTOS memory management
  27:Src/cortexm/stm32/stm32f4.c ****  *   -- Add function stm32f4_erase_flash()
  28:Src/cortexm/stm32/stm32f4.c ****  *   -- Add function stm32f4_erase_all_flash()
  29:Src/cortexm/stm32/stm32f4.c ****  *   -- Add function stm32f4_program()
  30:Src/cortexm/stm32/stm32f4.c ****  */
  31:Src/cortexm/stm32/stm32f4.c **** 
  32:Src/cortexm/stm32/stm32f4.c **** #include "stm32f4xx_it.h"
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 2


  33:Src/cortexm/stm32/stm32f4.c **** #include "cmsis_os.h"
  34:Src/cortexm/stm32/stm32f4.c **** #include "cortexm/cortexm.h"
  35:Src/cortexm/stm32/stm32f4.c **** #include "cortexm/stm32/stm32f4.h"
  36:Src/cortexm/stm32/stm32f4.c **** #include "fatfs.h"
  37:Src/cortexm/stm32/stm32f4.c **** #include "target.h"
  38:Src/cortexm/stm32/stm32f4.c **** 
  39:Src/cortexm/stm32/stm32f4.c **** /* This routine is uses word access.  Only usable on target voltage >2.7V */
  40:Src/cortexm/stm32/stm32f4.c **** static uint16_t stm32f4_flash_write_stub[] = {
  41:Src/cortexm/stm32/stm32f4.c **** // _start:
  42:Src/cortexm/stm32/stm32f4.c ****   0x480a,	// ldr r0, [pc, #40] // _flashbase
  43:Src/cortexm/stm32/stm32f4.c ****   0x490b,	// ldr r1, [pc, #44] // _addr
  44:Src/cortexm/stm32/stm32f4.c ****   0x467a, // mov r2, pc
  45:Src/cortexm/stm32/stm32f4.c ****   0x3230, // adds r2, #48
  46:Src/cortexm/stm32/stm32f4.c ****   0x4b0a, // ldr r3, [pc, #36] // _size
  47:Src/cortexm/stm32/stm32f4.c ****   0x4d07, // ldr r5, [pc, #28] // _cr
  48:Src/cortexm/stm32/stm32f4.c **** // _next:
  49:Src/cortexm/stm32/stm32f4.c ****   0xb153, // cbz r3, _done
  50:Src/cortexm/stm32/stm32f4.c ****   0x6105, // str r5, [r0, #16]
  51:Src/cortexm/stm32/stm32f4.c ****   0x6814, // ldr r4, [r2]
  52:Src/cortexm/stm32/stm32f4.c ****   0x600c, // str r4, [r1]
  53:Src/cortexm/stm32/stm32f4.c **** // _wait:
  54:Src/cortexm/stm32/stm32f4.c ****   0x89c4, // ldrb r4, [r0, #14]
  55:Src/cortexm/stm32/stm32f4.c ****   0x2601, // movs r6, #1
  56:Src/cortexm/stm32/stm32f4.c ****   0x4234, // tst r4, r6
  57:Src/cortexm/stm32/stm32f4.c ****   0xd1fb, // bne _wait
  58:Src/cortexm/stm32/stm32f4.c **** 
  59:Src/cortexm/stm32/stm32f4.c ****   0x3b04, // subs r3, #4
  60:Src/cortexm/stm32/stm32f4.c ****   0x3104, // adds r1, #4
  61:Src/cortexm/stm32/stm32f4.c ****   0x3204, // adds r2, #4
  62:Src/cortexm/stm32/stm32f4.c ****   0xe7f3, // b _next
  63:Src/cortexm/stm32/stm32f4.c **** // _done:
  64:Src/cortexm/stm32/stm32f4.c ****   0xbe00, // bkpt
  65:Src/cortexm/stm32/stm32f4.c ****   0x0000,
  66:Src/cortexm/stm32/stm32f4.c **** // .org 0x28
  67:Src/cortexm/stm32/stm32f4.c **** //_cr:
  68:Src/cortexm/stm32/stm32f4.c ****   0x0201, 0x0000, //.word 0x00000201 (Value to write to FLASH_CR) */
  69:Src/cortexm/stm32/stm32f4.c **** // _flashbase:
  70:Src/cortexm/stm32/stm32f4.c ****   0x3c00, 0x4002, // .word 0x40023c00 (FPEC_BASE)
  71:Src/cortexm/stm32/stm32f4.c **** // _addr: // to fill
  72:Src/cortexm/stm32/stm32f4.c ****   0x0000, 0x0000,
  73:Src/cortexm/stm32/stm32f4.c **** // _size: // to fill
  74:Src/cortexm/stm32/stm32f4.c ****   0x0000, 0x0000,
  75:Src/cortexm/stm32/stm32f4.c **** // _data:
  76:Src/cortexm/stm32/stm32f4.c **** // 	...
  77:Src/cortexm/stm32/stm32f4.c **** };
  78:Src/cortexm/stm32/stm32f4.c **** 
  79:Src/cortexm/stm32/stm32f4.c **** static void stm32f4_flash_unlock(STM32F4_PRIV_t *priv)
  80:Src/cortexm/stm32/stm32f4.c **** {
  81:Src/cortexm/stm32/stm32f4.c ****   printf("Flash unlock\n");
  82:Src/cortexm/stm32/stm32f4.c ****   if (priv->cortex->ops->read_word(priv->cortex->priv, STM32F4_FLASH_CR) & STM32F4_FLASH_CR_LOCK) {
  83:Src/cortexm/stm32/stm32f4.c ****     /* Enable FPEC controller access */
  84:Src/cortexm/stm32/stm32f4.c ****     priv->cortex->ops->write_word(priv->cortex->priv, STM32F4_FLASH_KEYR, STM32F4_KEY1);
  85:Src/cortexm/stm32/stm32f4.c ****     priv->cortex->ops->write_word(priv->cortex->priv, STM32F4_FLASH_KEYR, STM32F4_KEY2);
  86:Src/cortexm/stm32/stm32f4.c ****   }
  87:Src/cortexm/stm32/stm32f4.c **** }
  88:Src/cortexm/stm32/stm32f4.c **** 
  89:Src/cortexm/stm32/stm32f4.c **** static int stm32f4_erase_all_flash(STM32F4_PRIV_t *priv, int *progress, int progress_end)
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 3


  90:Src/cortexm/stm32/stm32f4.c **** {
  91:Src/cortexm/stm32/stm32f4.c ****   uint16_t sr;
  92:Src/cortexm/stm32/stm32f4.c ****   int time = 0;
  93:Src/cortexm/stm32/stm32f4.c ****   int progress_step = progress_end/10;
  94:Src/cortexm/stm32/stm32f4.c **** 
  95:Src/cortexm/stm32/stm32f4.c ****   /* Flash mass erase start instruction */
  96:Src/cortexm/stm32/stm32f4.c ****   priv->cortex->ops->write_word(priv->cortex->priv, STM32F4_FLASH_CR, STM32F4_FLASH_CR_MER);
  97:Src/cortexm/stm32/stm32f4.c ****   priv->cortex->ops->write_word(priv->cortex->priv, STM32F4_FLASH_CR, STM32F4_FLASH_CR_STRT | STM32
  98:Src/cortexm/stm32/stm32f4.c **** 
  99:Src/cortexm/stm32/stm32f4.c ****   /* Read FLASH_SR to poll for BSY bit */
 100:Src/cortexm/stm32/stm32f4.c ****   while(priv->cortex->ops->read_word(priv->cortex->priv, STM32F4_FLASH_SR) & STM32F4_FLASH_SR_BSY) 
 101:Src/cortexm/stm32/stm32f4.c ****     if(priv->cortex->ops->check_error(priv->cortex->priv)) {
 102:Src/cortexm/stm32/stm32f4.c ****       // TODO: handle error
 103:Src/cortexm/stm32/stm32f4.c ****       printf("Error while waiting for erase end\n");
 104:Src/cortexm/stm32/stm32f4.c ****       return STM32F4_ERASE_NEVER_END;
 105:Src/cortexm/stm32/stm32f4.c ****     }
 106:Src/cortexm/stm32/stm32f4.c ****     osDelay(10);
 107:Src/cortexm/stm32/stm32f4.c ****     time++;
 108:Src/cortexm/stm32/stm32f4.c ****     // after each 100 loops add one to progress, we asume that whole erase will take 1000 loops
 109:Src/cortexm/stm32/stm32f4.c ****     if(time > 100) {
 110:Src/cortexm/stm32/stm32f4.c ****       time = 0;
 111:Src/cortexm/stm32/stm32f4.c ****       if(*progress < progress_end - progress_step) {
 112:Src/cortexm/stm32/stm32f4.c ****         *progress += progress_step;
 113:Src/cortexm/stm32/stm32f4.c ****         printf("Flash progress %d\n", *progress);
 114:Src/cortexm/stm32/stm32f4.c ****       }
 115:Src/cortexm/stm32/stm32f4.c ****     }
 116:Src/cortexm/stm32/stm32f4.c ****   }
 117:Src/cortexm/stm32/stm32f4.c **** 
 118:Src/cortexm/stm32/stm32f4.c ****   /* Check for error */
 119:Src/cortexm/stm32/stm32f4.c ****   sr = priv->cortex->ops->read_word(priv->cortex->priv, STM32F4_FLASH_SR);
 120:Src/cortexm/stm32/stm32f4.c ****   if ((sr & STM32F4_SR_ERROR_MASK) || !(sr & STM32F4_SR_EOP)) {
 121:Src/cortexm/stm32/stm32f4.c ****     // TODO: handle error
 122:Src/cortexm/stm32/stm32f4.c ****     printf("Error after erase 0x%x\n", sr);
 123:Src/cortexm/stm32/stm32f4.c ****     return sr | STM32F4_ERASE_ERROR_BIT;
 124:Src/cortexm/stm32/stm32f4.c ****   }
 125:Src/cortexm/stm32/stm32f4.c **** 
 126:Src/cortexm/stm32/stm32f4.c ****   // End of erase, update progress
 127:Src/cortexm/stm32/stm32f4.c ****   *progress = progress_end;
 128:Src/cortexm/stm32/stm32f4.c ****   return 0;
 129:Src/cortexm/stm32/stm32f4.c **** }
 130:Src/cortexm/stm32/stm32f4.c **** 
 131:Src/cortexm/stm32/stm32f4.c **** // This function return how many sectors is needed in bank 1 of flash
 132:Src/cortexm/stm32/stm32f4.c **** // to save len bytes. If len is bigger then 7 sectors, return bigger number than number of sectors
 133:Src/cortexm/stm32/stm32f4.c **** static uint8_t stm32f4_sectors_in_bank1(int len)
 134:Src/cortexm/stm32/stm32f4.c **** {
  27              		.loc 1 134 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32              	.LVL0:
 135:Src/cortexm/stm32/stm32f4.c ****   uint8_t sector = 0;
  33              		.loc 1 135 0
  34 0000 0023     		movs	r3, #0
 136:Src/cortexm/stm32/stm32f4.c ****   while(len > 0) {
  35              		.loc 1 136 0
  36 0002 03E0     		b	.L2
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 4


  37              	.LVL1:
  38              	.L4:
 137:Src/cortexm/stm32/stm32f4.c ****     /*
 138:Src/cortexm/stm32/stm32f4.c ****      * Secotr sizes from:
 139:Src/cortexm/stm32/stm32f4.c ****      * RM0090 -- STM32F4xx reference manual, chapter 3.3
 140:Src/cortexm/stm32/stm32f4.c ****      */
 141:Src/cortexm/stm32/stm32f4.c ****     switch (sector) {
 142:Src/cortexm/stm32/stm32f4.c ****       case 0:
 143:Src/cortexm/stm32/stm32f4.c ****       case 1:
 144:Src/cortexm/stm32/stm32f4.c ****       case 2:
 145:Src/cortexm/stm32/stm32f4.c ****       case 3:
 146:Src/cortexm/stm32/stm32f4.c ****         len -= 0x4000;
  39              		.loc 1 146 0
  40 0004 A0F58040 		sub	r0, r0, #16384
  41              	.LVL2:
  42              	.L3:
 147:Src/cortexm/stm32/stm32f4.c ****         break;
 148:Src/cortexm/stm32/stm32f4.c ****       case 4:
 149:Src/cortexm/stm32/stm32f4.c ****         len -= 0x10000;
 150:Src/cortexm/stm32/stm32f4.c ****         break;
 151:Src/cortexm/stm32/stm32f4.c ****       case 5:
 152:Src/cortexm/stm32/stm32f4.c ****       case 6:
 153:Src/cortexm/stm32/stm32f4.c ****       case 7:
 154:Src/cortexm/stm32/stm32f4.c ****         len -= 0x20000;
 155:Src/cortexm/stm32/stm32f4.c ****         break;
 156:Src/cortexm/stm32/stm32f4.c ****       case 8:
 157:Src/cortexm/stm32/stm32f4.c ****         return 255;
 158:Src/cortexm/stm32/stm32f4.c ****     }
 159:Src/cortexm/stm32/stm32f4.c ****     sector++;
  43              		.loc 1 159 0
  44 0008 0133     		adds	r3, r3, #1
  45              	.LVL3:
  46 000a DBB2     		uxtb	r3, r3
  47              	.LVL4:
  48              	.L2:
 136:Src/cortexm/stm32/stm32f4.c ****     /*
  49              		.loc 1 136 0
  50 000c 0028     		cmp	r0, #0
  51 000e 1EDD     		ble	.L8
 141:Src/cortexm/stm32/stm32f4.c ****       case 0:
  52              		.loc 1 141 0
  53 0010 082B     		cmp	r3, #8
  54 0012 F9D8     		bhi	.L3
  55 0014 01A2     		adr	r2, .L5
  56 0016 52F823F0 		ldr	pc, [r2, r3, lsl #2]
  57 001a 00BF     		.p2align 2
  58              	.L5:
  59 001c 05000000 		.word	.L4+1
  60 0020 05000000 		.word	.L4+1
  61 0024 05000000 		.word	.L4+1
  62 0028 05000000 		.word	.L4+1
  63 002c 41000000 		.word	.L6+1
  64 0030 47000000 		.word	.L7+1
  65 0034 47000000 		.word	.L7+1
  66 0038 47000000 		.word	.L7+1
  67 003c 4D000000 		.word	.L10+1
  68              		.p2align 1
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 5


  69              	.L6:
 149:Src/cortexm/stm32/stm32f4.c ****         break;
  70              		.loc 1 149 0
  71 0040 A0F58030 		sub	r0, r0, #65536
  72              	.LVL5:
 150:Src/cortexm/stm32/stm32f4.c ****       case 5:
  73              		.loc 1 150 0
  74 0044 E0E7     		b	.L3
  75              	.L7:
 154:Src/cortexm/stm32/stm32f4.c ****         break;
  76              		.loc 1 154 0
  77 0046 A0F50030 		sub	r0, r0, #131072
  78              	.LVL6:
 155:Src/cortexm/stm32/stm32f4.c ****       case 8:
  79              		.loc 1 155 0
  80 004a DDE7     		b	.L3
  81              	.L10:
 157:Src/cortexm/stm32/stm32f4.c ****     }
  82              		.loc 1 157 0
  83 004c FF23     		movs	r3, #255
  84              	.LVL7:
  85              	.L8:
 160:Src/cortexm/stm32/stm32f4.c ****   }
 161:Src/cortexm/stm32/stm32f4.c ****   return sector;
 162:Src/cortexm/stm32/stm32f4.c **** }
  86              		.loc 1 162 0
  87 004e 1846     		mov	r0, r3
  88              	.LVL8:
  89 0050 7047     		bx	lr
  90              		.cfi_endproc
  91              	.LFE133:
  93 0052 00BF     		.section	.text.stm32f4_restart,"ax",%progbits
  94              		.align	1
  95              		.syntax unified
  96              		.thumb
  97              		.thumb_func
  98              		.fpu fpv4-sp-d16
 100              	stm32f4_restart:
 101              	.LFB137:
 163:Src/cortexm/stm32/stm32f4.c **** 
 164:Src/cortexm/stm32/stm32f4.c **** static int stm32f4_erase_flash(STM32F4_PRIV_t *priv, int len, int *progress, int progress_end)
 165:Src/cortexm/stm32/stm32f4.c **** {
 166:Src/cortexm/stm32/stm32f4.c ****   uint16_t sr;
 167:Src/cortexm/stm32/stm32f4.c ****   uint32_t cr;
 168:Src/cortexm/stm32/stm32f4.c ****   uint8_t  last_sector_to_flash = stm32f4_sectors_in_bank1(len);
 169:Src/cortexm/stm32/stm32f4.c ****   int progress_step = (progress_end + 31)/32;
 170:Src/cortexm/stm32/stm32f4.c **** 
 171:Src/cortexm/stm32/stm32f4.c ****   printf("Erase Flash\n");
 172:Src/cortexm/stm32/stm32f4.c ****   // TODO: For simplicity only when writing less than 512KB optimal sector erase
 173:Src/cortexm/stm32/stm32f4.c ****   //       algorithm is used. First 7 sectors are the same size which is independent
 174:Src/cortexm/stm32/stm32f4.c ****   //       of single and dual bank mode and size of flash memory.
 175:Src/cortexm/stm32/stm32f4.c ****   if(last_sector_to_flash > 7) {
 176:Src/cortexm/stm32/stm32f4.c ****     return stm32f4_erase_all_flash(priv, progress, progress_end);
 177:Src/cortexm/stm32/stm32f4.c ****   }
 178:Src/cortexm/stm32/stm32f4.c **** 
 179:Src/cortexm/stm32/stm32f4.c ****   for(uint8_t sector = 0; sector <= last_sector_to_flash; sector++) {
 180:Src/cortexm/stm32/stm32f4.c ****     cr = STM32F4_FLASH_CR_EOPIE | STM32F4_FLASH_CR_ERRIE | STM32F4_FLASH_CR_SER;
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 6


 181:Src/cortexm/stm32/stm32f4.c ****     cr |= sector << STM32F4_FLASH_CR_SNB_SHIFT;
 182:Src/cortexm/stm32/stm32f4.c ****     /* Flash page erase instruction */
 183:Src/cortexm/stm32/stm32f4.c ****     priv->cortex->ops->write_word(priv->cortex->priv, STM32F4_FLASH_CR, cr);
 184:Src/cortexm/stm32/stm32f4.c ****     /* write address to FMA */
 185:Src/cortexm/stm32/stm32f4.c ****     priv->cortex->ops->write_word(priv->cortex->priv, STM32F4_FLASH_CR, cr | STM32F4_FLASH_CR_STRT)
 186:Src/cortexm/stm32/stm32f4.c ****     /* Read FLASH_SR to poll for BSY bit */
 187:Src/cortexm/stm32/stm32f4.c ****     while(priv->cortex->ops->read_word(priv->cortex->priv, STM32F4_FLASH_SR) & STM32F4_FLASH_SR_BSY
 188:Src/cortexm/stm32/stm32f4.c ****       if(priv->cortex->ops->check_error(priv->cortex->priv)) {
 189:Src/cortexm/stm32/stm32f4.c ****         // TODO: handle error
 190:Src/cortexm/stm32/stm32f4.c ****         printf("Error while waiting for erase end\n");
 191:Src/cortexm/stm32/stm32f4.c ****         return STM32F4_ERASE_NEVER_END;
 192:Src/cortexm/stm32/stm32f4.c ****       }
 193:Src/cortexm/stm32/stm32f4.c ****     }
 194:Src/cortexm/stm32/stm32f4.c ****     *progress += progress_step;
 195:Src/cortexm/stm32/stm32f4.c ****     printf("Flash progress %d\n", *progress);
 196:Src/cortexm/stm32/stm32f4.c ****   }
 197:Src/cortexm/stm32/stm32f4.c **** 
 198:Src/cortexm/stm32/stm32f4.c ****   /* Check for error */
 199:Src/cortexm/stm32/stm32f4.c ****   sr = priv->cortex->ops->read_word(priv->cortex->priv, STM32F4_FLASH_SR);
 200:Src/cortexm/stm32/stm32f4.c ****   if ((sr & STM32F4_SR_ERROR_MASK) || !(sr & STM32F4_SR_EOP)) {
 201:Src/cortexm/stm32/stm32f4.c ****     // TODO: handle error
 202:Src/cortexm/stm32/stm32f4.c ****     printf("Error after erase 0x%x\n", sr);
 203:Src/cortexm/stm32/stm32f4.c ****     return sr | STM32F4_ERASE_ERROR_BIT;
 204:Src/cortexm/stm32/stm32f4.c ****   }
 205:Src/cortexm/stm32/stm32f4.c **** 
 206:Src/cortexm/stm32/stm32f4.c ****   return 0;
 207:Src/cortexm/stm32/stm32f4.c **** }
 208:Src/cortexm/stm32/stm32f4.c **** 
 209:Src/cortexm/stm32/stm32f4.c **** static int stm32f4_flash_write(STM32F4_PRIV_t *priv, uint32_t dest, const uint32_t *src, int len)
 210:Src/cortexm/stm32/stm32f4.c **** {
 211:Src/cortexm/stm32/stm32f4.c ****   uint32_t start_of_ram = 0x20000000;
 212:Src/cortexm/stm32/stm32f4.c ****   uint32_t stub_len = 0x38;
 213:Src/cortexm/stm32/stm32f4.c ****   uint16_t sr;
 214:Src/cortexm/stm32/stm32f4.c **** 
 215:Src/cortexm/stm32/stm32f4.c ****   /* Fill stm32f4_flash_write_stub with address and size */
 216:Src/cortexm/stm32/stm32f4.c **** 	*(uint32_t *)&(stm32f4_flash_write_stub[24]) = dest;
 217:Src/cortexm/stm32/stm32f4.c ****   *(uint32_t *)&(stm32f4_flash_write_stub[26]) = len;
 218:Src/cortexm/stm32/stm32f4.c **** 
 219:Src/cortexm/stm32/stm32f4.c ****   /* Write stub and data to target ram and set PC */
 220:Src/cortexm/stm32/stm32f4.c ****   priv->cortex->ops->write_words(priv->cortex->priv, start_of_ram, (void*)stm32f4_flash_write_stub,
 221:Src/cortexm/stm32/stm32f4.c ****   priv->cortex->ops->write_words(priv->cortex->priv, start_of_ram + stub_len, src, len);
 222:Src/cortexm/stm32/stm32f4.c ****   priv->cortex->ops->pc_write(priv->cortex->priv, start_of_ram);
 223:Src/cortexm/stm32/stm32f4.c ****   if(priv->cortex->ops->check_error(priv->cortex->priv)) {
 224:Src/cortexm/stm32/stm32f4.c ****     // TODO: handle error
 225:Src/cortexm/stm32/stm32f4.c ****     printf("ERROR: Filed to setup write operation\n");
 226:Src/cortexm/stm32/stm32f4.c ****     return STM32F4_ERROR_ON_FLASH_WRITE_SETUP;
 227:Src/cortexm/stm32/stm32f4.c ****   }
 228:Src/cortexm/stm32/stm32f4.c **** 
 229:Src/cortexm/stm32/stm32f4.c ****   /* Execute the stub */
 230:Src/cortexm/stm32/stm32f4.c ****   priv->cortex->ops->halt_resume(priv->cortex->priv);
 231:Src/cortexm/stm32/stm32f4.c ****   while(!priv->cortex->ops->halt_wait(priv->cortex->priv)) {
 232:Src/cortexm/stm32/stm32f4.c ****     // Don't be greedy about CPU, allow another task
 233:Src/cortexm/stm32/stm32f4.c ****     osDelay(10);
 234:Src/cortexm/stm32/stm32f4.c ****   }
 235:Src/cortexm/stm32/stm32f4.c **** 
 236:Src/cortexm/stm32/stm32f4.c ****   /* Check for error */
 237:Src/cortexm/stm32/stm32f4.c ****   sr = priv->cortex->ops->read_word(priv->cortex->priv, STM32F4_FLASH_SR);
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 7


 238:Src/cortexm/stm32/stm32f4.c ****   if (sr & STM32F4_SR_ERROR_MASK) {
 239:Src/cortexm/stm32/stm32f4.c ****     // TODO: handle error
 240:Src/cortexm/stm32/stm32f4.c ****     printf("ERROR: writing ended with error 0x%x\n", sr);
 241:Src/cortexm/stm32/stm32f4.c ****     return sr | STM32F4_FLASH_ERROR_BIT;
 242:Src/cortexm/stm32/stm32f4.c ****   }
 243:Src/cortexm/stm32/stm32f4.c **** 
 244:Src/cortexm/stm32/stm32f4.c ****   return 0;
 245:Src/cortexm/stm32/stm32f4.c **** }
 246:Src/cortexm/stm32/stm32f4.c **** 
 247:Src/cortexm/stm32/stm32f4.c **** static int stm32f4_program(void *priv_void, FIL *file, int *progress)
 248:Src/cortexm/stm32/stm32f4.c **** {
 249:Src/cortexm/stm32/stm32f4.c ****   UINT br;
 250:Src/cortexm/stm32/stm32f4.c ****   uint8_t unaligned;
 251:Src/cortexm/stm32/stm32f4.c ****   uint32_t addr = 0x8000000; // start of flash memory
 252:Src/cortexm/stm32/stm32f4.c ****   uint32_t *data = pvPortMalloc(STM32F4_SIZE_OF_ONE_WRITE);
 253:Src/cortexm/stm32/stm32f4.c ****   STM32F4_PRIV_t *priv = priv_void;
 254:Src/cortexm/stm32/stm32f4.c ****   uint16_t result;
 255:Src/cortexm/stm32/stm32f4.c ****   uint32_t file_len = f_size(file);
 256:Src/cortexm/stm32/stm32f4.c **** 
 257:Src/cortexm/stm32/stm32f4.c ****   // these variables are only needed to show progress
 258:Src/cortexm/stm32/stm32f4.c ****   int number_of_writes = (file_len + STM32F4_SIZE_OF_ONE_WRITE - 1)/STM32F4_SIZE_OF_ONE_WRITE;
 259:Src/cortexm/stm32/stm32f4.c ****   float progress_as_float = 100 * STM32F4_ERASE_TIME_IN_WRITES/(number_of_writes + STM32F4_ERASE_TI
 260:Src/cortexm/stm32/stm32f4.c ****   float progress_on_one_write;
 261:Src/cortexm/stm32/stm32f4.c **** 
 262:Src/cortexm/stm32/stm32f4.c ****   printf("Start flashing STM32F4x\n");
 263:Src/cortexm/stm32/stm32f4.c **** 
 264:Src/cortexm/stm32/stm32f4.c ****   priv->cortex->ops->halt_request(priv->cortex->priv);
 265:Src/cortexm/stm32/stm32f4.c ****   stm32f4_flash_unlock(priv);
 266:Src/cortexm/stm32/stm32f4.c ****   result = stm32f4_erase_flash(priv, file_len, progress, progress_as_float);
 267:Src/cortexm/stm32/stm32f4.c ****   if(result) {
 268:Src/cortexm/stm32/stm32f4.c ****     vPortFree(data);
 269:Src/cortexm/stm32/stm32f4.c ****     return result;
 270:Src/cortexm/stm32/stm32f4.c ****   }
 271:Src/cortexm/stm32/stm32f4.c **** 
 272:Src/cortexm/stm32/stm32f4.c ****   progress_as_float = *progress;
 273:Src/cortexm/stm32/stm32f4.c ****   progress_on_one_write = (100 - *progress)/number_of_writes;
 274:Src/cortexm/stm32/stm32f4.c **** 
 275:Src/cortexm/stm32/stm32f4.c ****   do {
 276:Src/cortexm/stm32/stm32f4.c ****     f_read(file, data, STM32F4_SIZE_OF_ONE_WRITE, &br);
 277:Src/cortexm/stm32/stm32f4.c ****     printf("flash 0x%x bytes on 0x%lx\n", br, addr);
 278:Src/cortexm/stm32/stm32f4.c ****     unaligned = br & 0x3;
 279:Src/cortexm/stm32/stm32f4.c ****     if (unaligned) {
 280:Src/cortexm/stm32/stm32f4.c ****       // If number of readed bytes % sizeof(uint32_t) != 0, last readed bytes are unaligned.
 281:Src/cortexm/stm32/stm32f4.c ****       // Fill all unreaded bytes in last 4 bytes as 0xFF. This way flash is not damaged
 282:Src/cortexm/stm32/stm32f4.c ****       // by writing additional (1..3) bytes.
 283:Src/cortexm/stm32/stm32f4.c ****       br >>= 2;
 284:Src/cortexm/stm32/stm32f4.c ****       data[br] |= ((~0) >> (unaligned << 0x3));
 285:Src/cortexm/stm32/stm32f4.c ****       // add modified bytes to bytes that will be written
 286:Src/cortexm/stm32/stm32f4.c ****       br++;
 287:Src/cortexm/stm32/stm32f4.c ****       br <<= 2;
 288:Src/cortexm/stm32/stm32f4.c ****       result = stm32f4_flash_write(priv, addr, data, br);
 289:Src/cortexm/stm32/stm32f4.c ****       if(result) {
 290:Src/cortexm/stm32/stm32f4.c ****         vPortFree(data);
 291:Src/cortexm/stm32/stm32f4.c ****         return result;
 292:Src/cortexm/stm32/stm32f4.c ****       }
 293:Src/cortexm/stm32/stm32f4.c ****       // Unaligned read is always smaller then SIZE_OF_ONE_WRITE.
 294:Src/cortexm/stm32/stm32f4.c ****       // This is EOF so we have done here.
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 8


 295:Src/cortexm/stm32/stm32f4.c ****       break;
 296:Src/cortexm/stm32/stm32f4.c ****     }
 297:Src/cortexm/stm32/stm32f4.c ****     result = stm32f4_flash_write(priv, addr, data, br);
 298:Src/cortexm/stm32/stm32f4.c ****     if(result) {
 299:Src/cortexm/stm32/stm32f4.c ****       vPortFree(data);
 300:Src/cortexm/stm32/stm32f4.c ****       return 1;
 301:Src/cortexm/stm32/stm32f4.c ****     }
 302:Src/cortexm/stm32/stm32f4.c ****     addr += br;
 303:Src/cortexm/stm32/stm32f4.c **** 
 304:Src/cortexm/stm32/stm32f4.c ****     progress_as_float += progress_on_one_write;
 305:Src/cortexm/stm32/stm32f4.c ****     *progress = (int)progress_as_float;
 306:Src/cortexm/stm32/stm32f4.c ****     printf("Flash progress %d\n", *progress);
 307:Src/cortexm/stm32/stm32f4.c **** 
 308:Src/cortexm/stm32/stm32f4.c ****     // EOF is when readed less bytes than requested
 309:Src/cortexm/stm32/stm32f4.c ****   } while(br == STM32F4_SIZE_OF_ONE_WRITE);
 310:Src/cortexm/stm32/stm32f4.c **** 
 311:Src/cortexm/stm32/stm32f4.c ****   vPortFree(data);
 312:Src/cortexm/stm32/stm32f4.c **** 
 313:Src/cortexm/stm32/stm32f4.c ****   printf("Device flashed\nReset device\n");
 314:Src/cortexm/stm32/stm32f4.c ****   priv->cortex->ops->restart(priv->cortex->priv);
 315:Src/cortexm/stm32/stm32f4.c **** 
 316:Src/cortexm/stm32/stm32f4.c ****   *progress = 100;
 317:Src/cortexm/stm32/stm32f4.c ****   return 0;
 318:Src/cortexm/stm32/stm32f4.c **** }
 319:Src/cortexm/stm32/stm32f4.c **** 
 320:Src/cortexm/stm32/stm32f4.c **** static void stm32f4_restart(void *priv)
 321:Src/cortexm/stm32/stm32f4.c **** {
 102              		.loc 1 321 0
 103              		.cfi_startproc
 104              		@ args = 0, pretend = 0, frame = 0
 105              		@ frame_needed = 0, uses_anonymous_args = 0
 106              	.LVL9:
 107 0000 08B5     		push	{r3, lr}
 108              	.LCFI0:
 109              		.cfi_def_cfa_offset 8
 110              		.cfi_offset 3, -8
 111              		.cfi_offset 14, -4
 322:Src/cortexm/stm32/stm32f4.c ****   ((STM32F4_PRIV_t*)priv)->cortex->ops->restart(((STM32F4_PRIV_t*)priv)->cortex->priv);
 112              		.loc 1 322 0
 113 0002 0368     		ldr	r3, [r0]
 114 0004 1A68     		ldr	r2, [r3]
 115 0006 926A     		ldr	r2, [r2, #40]
 116 0008 5868     		ldr	r0, [r3, #4]
 117              	.LVL10:
 118 000a 9047     		blx	r2
 119              	.LVL11:
 323:Src/cortexm/stm32/stm32f4.c **** }
 120              		.loc 1 323 0
 121 000c 08BD     		pop	{r3, pc}
 122              		.cfi_endproc
 123              	.LFE137:
 125              		.section	.text.stm32f4_free_priv,"ax",%progbits
 126              		.align	1
 127              		.syntax unified
 128              		.thumb
 129              		.thumb_func
 130              		.fpu fpv4-sp-d16
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 9


 132              	stm32f4_free_priv:
 133              	.LFB138:
 324:Src/cortexm/stm32/stm32f4.c **** 
 325:Src/cortexm/stm32/stm32f4.c **** static void stm32f4_free_priv(void *priv){
 134              		.loc 1 325 0
 135              		.cfi_startproc
 136              		@ args = 0, pretend = 0, frame = 0
 137              		@ frame_needed = 0, uses_anonymous_args = 0
 138              	.LVL12:
 139 0000 10B5     		push	{r4, lr}
 140              	.LCFI1:
 141              		.cfi_def_cfa_offset 8
 142              		.cfi_offset 4, -8
 143              		.cfi_offset 14, -4
 144 0002 0446     		mov	r4, r0
 326:Src/cortexm/stm32/stm32f4.c ****   ((STM32F4_PRIV_t*)priv)->cortex->ops->free(((STM32F4_PRIV_t*)priv)->cortex);
 145              		.loc 1 326 0
 146 0004 0068     		ldr	r0, [r0]
 147              	.LVL13:
 148 0006 0368     		ldr	r3, [r0]
 149 0008 DB6A     		ldr	r3, [r3, #44]
 150 000a 9847     		blx	r3
 151              	.LVL14:
 327:Src/cortexm/stm32/stm32f4.c ****   vPortFree(priv);
 152              		.loc 1 327 0
 153 000c 2046     		mov	r0, r4
 154 000e FFF7FEFF 		bl	vPortFree
 155              	.LVL15:
 328:Src/cortexm/stm32/stm32f4.c **** }
 156              		.loc 1 328 0
 157 0012 10BD     		pop	{r4, pc}
 158              		.cfi_endproc
 159              	.LFE138:
 161              		.section	.text.stm32f4_flash_unlock,"ax",%progbits
 162              		.align	1
 163              		.syntax unified
 164              		.thumb
 165              		.thumb_func
 166              		.fpu fpv4-sp-d16
 168              	stm32f4_flash_unlock:
 169              	.LFB131:
  80:Src/cortexm/stm32/stm32f4.c ****   printf("Flash unlock\n");
 170              		.loc 1 80 0
 171              		.cfi_startproc
 172              		@ args = 0, pretend = 0, frame = 0
 173              		@ frame_needed = 0, uses_anonymous_args = 0
 174              	.LVL16:
 175 0000 70B5     		push	{r4, r5, r6, lr}
 176              	.LCFI2:
 177              		.cfi_def_cfa_offset 16
 178              		.cfi_offset 4, -16
 179              		.cfi_offset 5, -12
 180              		.cfi_offset 6, -8
 181              		.cfi_offset 14, -4
 182 0002 0446     		mov	r4, r0
  81:Src/cortexm/stm32/stm32f4.c ****   if (priv->cortex->ops->read_word(priv->cortex->priv, STM32F4_FLASH_CR) & STM32F4_FLASH_CR_LOCK) {
 183              		.loc 1 81 0
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 10


 184 0004 0D48     		ldr	r0, .L18
 185              	.LVL17:
 186 0006 FFF7FEFF 		bl	puts
 187              	.LVL18:
  82:Src/cortexm/stm32/stm32f4.c ****     /* Enable FPEC controller access */
 188              		.loc 1 82 0
 189 000a 2368     		ldr	r3, [r4]
 190 000c 1A68     		ldr	r2, [r3]
 191 000e 1268     		ldr	r2, [r2]
 192 0010 0B49     		ldr	r1, .L18+4
 193 0012 5868     		ldr	r0, [r3, #4]
 194 0014 9047     		blx	r2
 195              	.LVL19:
 196 0016 0028     		cmp	r0, #0
 197 0018 0EDA     		bge	.L15
  84:Src/cortexm/stm32/stm32f4.c ****     priv->cortex->ops->write_word(priv->cortex->priv, STM32F4_FLASH_KEYR, STM32F4_KEY2);
 198              		.loc 1 84 0
 199 001a 2368     		ldr	r3, [r4]
 200 001c 1A68     		ldr	r2, [r3]
 201 001e 5668     		ldr	r6, [r2, #4]
 202 0020 084D     		ldr	r5, .L18+8
 203 0022 094A     		ldr	r2, .L18+12
 204 0024 2946     		mov	r1, r5
 205 0026 5868     		ldr	r0, [r3, #4]
 206 0028 B047     		blx	r6
 207              	.LVL20:
  85:Src/cortexm/stm32/stm32f4.c ****   }
 208              		.loc 1 85 0
 209 002a 2368     		ldr	r3, [r4]
 210 002c 1A68     		ldr	r2, [r3]
 211 002e 5468     		ldr	r4, [r2, #4]
 212              	.LVL21:
 213 0030 064A     		ldr	r2, .L18+16
 214 0032 2946     		mov	r1, r5
 215 0034 5868     		ldr	r0, [r3, #4]
 216 0036 A047     		blx	r4
 217              	.LVL22:
 218              	.L15:
  87:Src/cortexm/stm32/stm32f4.c **** 
 219              		.loc 1 87 0
 220 0038 70BD     		pop	{r4, r5, r6, pc}
 221              	.L19:
 222 003a 00BF     		.align	2
 223              	.L18:
 224 003c 00000000 		.word	.LC0
 225 0040 103C0240 		.word	1073888272
 226 0044 043C0240 		.word	1073888260
 227 0048 23016745 		.word	1164378403
 228 004c AB89EFCD 		.word	-839939669
 229              		.cfi_endproc
 230              	.LFE131:
 232              		.section	.text.stm32f4_erase_all_flash,"ax",%progbits
 233              		.align	1
 234              		.syntax unified
 235              		.thumb
 236              		.thumb_func
 237              		.fpu fpv4-sp-d16
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 11


 239              	stm32f4_erase_all_flash:
 240              	.LFB132:
  90:Src/cortexm/stm32/stm32f4.c ****   uint16_t sr;
 241              		.loc 1 90 0
 242              		.cfi_startproc
 243              		@ args = 0, pretend = 0, frame = 0
 244              		@ frame_needed = 0, uses_anonymous_args = 0
 245              	.LVL23:
 246 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 247              	.LCFI3:
 248              		.cfi_def_cfa_offset 32
 249              		.cfi_offset 3, -32
 250              		.cfi_offset 4, -28
 251              		.cfi_offset 5, -24
 252              		.cfi_offset 6, -20
 253              		.cfi_offset 7, -16
 254              		.cfi_offset 8, -12
 255              		.cfi_offset 9, -8
 256              		.cfi_offset 14, -4
 257 0004 0546     		mov	r5, r0
 258 0006 8846     		mov	r8, r1
 259 0008 1746     		mov	r7, r2
 260              	.LVL24:
  93:Src/cortexm/stm32/stm32f4.c **** 
 261              		.loc 1 93 0
 262 000a 2C4B     		ldr	r3, .L33
 263 000c 83FB0723 		smull	r2, r3, r3, r7
 264              	.LVL25:
 265 0010 FE17     		asrs	r6, r7, #31
 266 0012 C6EBA306 		rsb	r6, r6, r3, asr #2
 267              	.LVL26:
  96:Src/cortexm/stm32/stm32f4.c ****   priv->cortex->ops->write_word(priv->cortex->priv, STM32F4_FLASH_CR, STM32F4_FLASH_CR_STRT | STM32
 268              		.loc 1 96 0
 269 0016 0368     		ldr	r3, [r0]
 270 0018 1A68     		ldr	r2, [r3]
 271 001a D2F80490 		ldr	r9, [r2, #4]
 272 001e 284C     		ldr	r4, .L33+4
 273 0020 0422     		movs	r2, #4
 274 0022 2146     		mov	r1, r4
 275              	.LVL27:
 276 0024 5868     		ldr	r0, [r3, #4]
 277              	.LVL28:
 278 0026 C847     		blx	r9
 279              	.LVL29:
  97:Src/cortexm/stm32/stm32f4.c **** 
 280              		.loc 1 97 0
 281 0028 2B68     		ldr	r3, [r5]
 282 002a 1A68     		ldr	r2, [r3]
 283 002c D2F80490 		ldr	r9, [r2, #4]
 284 0030 244A     		ldr	r2, .L33+8
 285 0032 2146     		mov	r1, r4
 286 0034 5868     		ldr	r0, [r3, #4]
 287 0036 C847     		blx	r9
 288              	.LVL30:
  92:Src/cortexm/stm32/stm32f4.c ****   int progress_step = progress_end/10;
 289              		.loc 1 92 0
 290 0038 0024     		movs	r4, #0
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 12


 291              	.LVL31:
 292              	.L21:
 100:Src/cortexm/stm32/stm32f4.c ****     if(priv->cortex->ops->check_error(priv->cortex->priv)) {
 293              		.loc 1 100 0
 294 003a 2B68     		ldr	r3, [r5]
 295 003c 1A68     		ldr	r2, [r3]
 296 003e 1268     		ldr	r2, [r2]
 297 0040 2149     		ldr	r1, .L33+12
 298 0042 5868     		ldr	r0, [r3, #4]
 299 0044 9047     		blx	r2
 300              	.LVL32:
 301 0046 10F4803F 		tst	r0, #65536
 302 004a 21D0     		beq	.L29
 101:Src/cortexm/stm32/stm32f4.c ****       // TODO: handle error
 303              		.loc 1 101 0
 304 004c 2B68     		ldr	r3, [r5]
 305 004e 1A68     		ldr	r2, [r3]
 306 0050 526A     		ldr	r2, [r2, #36]
 307 0052 5868     		ldr	r0, [r3, #4]
 308 0054 9047     		blx	r2
 309              	.LVL33:
 310 0056 60B9     		cbnz	r0, .L30
 106:Src/cortexm/stm32/stm32f4.c ****     time++;
 311              		.loc 1 106 0
 312 0058 0A20     		movs	r0, #10
 313 005a FFF7FEFF 		bl	osDelay
 314              	.LVL34:
 107:Src/cortexm/stm32/stm32f4.c ****     // after each 100 loops add one to progress, we asume that whole erase will take 1000 loops
 315              		.loc 1 107 0
 316 005e 0134     		adds	r4, r4, #1
 317              	.LVL35:
 109:Src/cortexm/stm32/stm32f4.c ****       time = 0;
 318              		.loc 1 109 0
 319 0060 642C     		cmp	r4, #100
 320 0062 EADD     		ble	.L21
 321              	.LVL36:
 111:Src/cortexm/stm32/stm32f4.c ****         *progress += progress_step;
 322              		.loc 1 111 0
 323 0064 D8F80010 		ldr	r1, [r8]
 324 0068 BB1B     		subs	r3, r7, r6
 325 006a 9942     		cmp	r1, r3
 326 006c 08DB     		blt	.L31
 110:Src/cortexm/stm32/stm32f4.c ****       if(*progress < progress_end - progress_step) {
 327              		.loc 1 110 0
 328 006e 0024     		movs	r4, #0
 329 0070 E3E7     		b	.L21
 330              	.LVL37:
 331              	.L30:
 103:Src/cortexm/stm32/stm32f4.c ****       return STM32F4_ERASE_NEVER_END;
 332              		.loc 1 103 0
 333 0072 1648     		ldr	r0, .L33+16
 334 0074 FFF7FEFF 		bl	puts
 335              	.LVL38:
 104:Src/cortexm/stm32/stm32f4.c ****     }
 336              		.loc 1 104 0
 337 0078 4FF40060 		mov	r0, #2048
 338              	.LVL39:
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 13


 339              	.L20:
 129:Src/cortexm/stm32/stm32f4.c **** 
 340              		.loc 1 129 0
 341 007c BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 342              	.LVL40:
 343              	.L31:
 112:Src/cortexm/stm32/stm32f4.c ****         printf("Flash progress %d\n", *progress);
 344              		.loc 1 112 0
 345 0080 3144     		add	r1, r1, r6
 346 0082 C8F80010 		str	r1, [r8]
 113:Src/cortexm/stm32/stm32f4.c ****       }
 347              		.loc 1 113 0
 348 0086 1248     		ldr	r0, .L33+20
 349 0088 FFF7FEFF 		bl	printf
 350              	.LVL41:
 110:Src/cortexm/stm32/stm32f4.c ****       if(*progress < progress_end - progress_step) {
 351              		.loc 1 110 0
 352 008c 0024     		movs	r4, #0
 353 008e D4E7     		b	.L21
 354              	.LVL42:
 355              	.L29:
 119:Src/cortexm/stm32/stm32f4.c ****   if ((sr & STM32F4_SR_ERROR_MASK) || !(sr & STM32F4_SR_EOP)) {
 356              		.loc 1 119 0
 357 0090 2B68     		ldr	r3, [r5]
 358 0092 1A68     		ldr	r2, [r3]
 359 0094 1268     		ldr	r2, [r2]
 360 0096 0C49     		ldr	r1, .L33+12
 361 0098 5868     		ldr	r0, [r3, #4]
 362 009a 9047     		blx	r2
 363              	.LVL43:
 364 009c 84B2     		uxth	r4, r0
 365              	.LVL44:
 120:Src/cortexm/stm32/stm32f4.c ****     // TODO: handle error
 366              		.loc 1 120 0
 367 009e 00F0F300 		and	r0, r0, #243
 368 00a2 0128     		cmp	r0, #1
 369 00a4 03D1     		bne	.L32
 127:Src/cortexm/stm32/stm32f4.c ****   return 0;
 370              		.loc 1 127 0
 371 00a6 C8F80070 		str	r7, [r8]
 128:Src/cortexm/stm32/stm32f4.c **** }
 372              		.loc 1 128 0
 373 00aa 0020     		movs	r0, #0
 374 00ac E6E7     		b	.L20
 375              	.L32:
 122:Src/cortexm/stm32/stm32f4.c ****     return sr | STM32F4_ERASE_ERROR_BIT;
 376              		.loc 1 122 0
 377 00ae 2146     		mov	r1, r4
 378 00b0 0848     		ldr	r0, .L33+24
 379 00b2 FFF7FEFF 		bl	printf
 380              	.LVL45:
 123:Src/cortexm/stm32/stm32f4.c ****   }
 381              		.loc 1 123 0
 382 00b6 44F40070 		orr	r0, r4, #512
 383 00ba DFE7     		b	.L20
 384              	.L34:
 385              		.align	2
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 14


 386              	.L33:
 387 00bc 67666666 		.word	1717986919
 388 00c0 103C0240 		.word	1073888272
 389 00c4 04000101 		.word	16842756
 390 00c8 0C3C0240 		.word	1073888268
 391 00cc 00000000 		.word	.LC1
 392 00d0 24000000 		.word	.LC2
 393 00d4 38000000 		.word	.LC3
 394              		.cfi_endproc
 395              	.LFE132:
 397              		.section	.text.stm32f4_erase_flash,"ax",%progbits
 398              		.align	1
 399              		.syntax unified
 400              		.thumb
 401              		.thumb_func
 402              		.fpu fpv4-sp-d16
 404              	stm32f4_erase_flash:
 405              	.LFB134:
 165:Src/cortexm/stm32/stm32f4.c ****   uint16_t sr;
 406              		.loc 1 165 0
 407              		.cfi_startproc
 408              		@ args = 0, pretend = 0, frame = 0
 409              		@ frame_needed = 0, uses_anonymous_args = 0
 410              	.LVL46:
 411 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 412              	.LCFI4:
 413              		.cfi_def_cfa_offset 40
 414              		.cfi_offset 3, -40
 415              		.cfi_offset 4, -36
 416              		.cfi_offset 5, -32
 417              		.cfi_offset 6, -28
 418              		.cfi_offset 7, -24
 419              		.cfi_offset 8, -20
 420              		.cfi_offset 9, -16
 421              		.cfi_offset 10, -12
 422              		.cfi_offset 11, -8
 423              		.cfi_offset 14, -4
 424 0004 0446     		mov	r4, r0
 425 0006 9046     		mov	r8, r2
 426 0008 1D46     		mov	r5, r3
 168:Src/cortexm/stm32/stm32f4.c ****   int progress_step = (progress_end + 31)/32;
 427              		.loc 1 168 0
 428 000a 0846     		mov	r0, r1
 429              	.LVL47:
 430 000c FFF7FEFF 		bl	stm32f4_sectors_in_bank1
 431              	.LVL48:
 432 0010 0746     		mov	r7, r0
 433              	.LVL49:
 169:Src/cortexm/stm32/stm32f4.c **** 
 434              		.loc 1 169 0
 435 0012 15F11F06 		adds	r6, r5, #31
 436 0016 38D4     		bmi	.L45
 437              	.L36:
 438 0018 7611     		asrs	r6, r6, #5
 439              	.LVL50:
 171:Src/cortexm/stm32/stm32f4.c ****   // TODO: For simplicity only when writing less than 512KB optimal sector erase
 440              		.loc 1 171 0
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 15


 441 001a 2F48     		ldr	r0, .L49
 442 001c FFF7FEFF 		bl	puts
 443              	.LVL51:
 175:Src/cortexm/stm32/stm32f4.c ****     return stm32f4_erase_all_flash(priv, progress, progress_end);
 444              		.loc 1 175 0
 445 0020 072F     		cmp	r7, #7
 446 0022 34D8     		bhi	.L46
 447              	.LBB2:
 179:Src/cortexm/stm32/stm32f4.c ****     cr = STM32F4_FLASH_CR_EOPIE | STM32F4_FLASH_CR_ERRIE | STM32F4_FLASH_CR_SER;
 448              		.loc 1 179 0
 449 0024 0025     		movs	r5, #0
 450              	.LVL52:
 451              	.L37:
 179:Src/cortexm/stm32/stm32f4.c ****     cr = STM32F4_FLASH_CR_EOPIE | STM32F4_FLASH_CR_ERRIE | STM32F4_FLASH_CR_SER;
 452              		.loc 1 179 0 is_stmt 0 discriminator 1
 453 0026 BD42     		cmp	r5, r7
 454 0028 42D8     		bhi	.L47
 455              	.LVL53:
 181:Src/cortexm/stm32/stm32f4.c ****     /* Flash page erase instruction */
 456              		.loc 1 181 0 is_stmt 1
 457 002a 4FEAC509 		lsl	r9, r5, #3
 458              	.LVL54:
 183:Src/cortexm/stm32/stm32f4.c ****     /* write address to FMA */
 459              		.loc 1 183 0
 460 002e 2368     		ldr	r3, [r4]
 461 0030 1A68     		ldr	r2, [r3]
 462 0032 D2F804B0 		ldr	fp, [r2, #4]
 463 0036 DFF8B8A0 		ldr	r10, .L49+24
 464 003a 49F04072 		orr	r2, r9, #50331648
 465 003e 42F00202 		orr	r2, r2, #2
 466 0042 5146     		mov	r1, r10
 467 0044 5868     		ldr	r0, [r3, #4]
 468 0046 D847     		blx	fp
 469              	.LVL55:
 185:Src/cortexm/stm32/stm32f4.c ****     /* Read FLASH_SR to poll for BSY bit */
 470              		.loc 1 185 0
 471 0048 2368     		ldr	r3, [r4]
 472 004a 1A68     		ldr	r2, [r3]
 473 004c D2F804B0 		ldr	fp, [r2, #4]
 474 0050 224A     		ldr	r2, .L49+4
 475 0052 49EA0202 		orr	r2, r9, r2
 476 0056 5146     		mov	r1, r10
 477 0058 5868     		ldr	r0, [r3, #4]
 478 005a D847     		blx	fp
 479              	.LVL56:
 480              	.L39:
 187:Src/cortexm/stm32/stm32f4.c ****       if(priv->cortex->ops->check_error(priv->cortex->priv)) {
 481              		.loc 1 187 0
 482 005c 2368     		ldr	r3, [r4]
 483 005e 1A68     		ldr	r2, [r3]
 484 0060 1268     		ldr	r2, [r2]
 485 0062 1F49     		ldr	r1, .L49+8
 486 0064 5868     		ldr	r0, [r3, #4]
 487 0066 9047     		blx	r2
 488              	.LVL57:
 489 0068 10F4803F 		tst	r0, #65536
 490 006c 15D0     		beq	.L48
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 16


 188:Src/cortexm/stm32/stm32f4.c ****         // TODO: handle error
 491              		.loc 1 188 0
 492 006e 2368     		ldr	r3, [r4]
 493 0070 1A68     		ldr	r2, [r3]
 494 0072 526A     		ldr	r2, [r2, #36]
 495 0074 5868     		ldr	r0, [r3, #4]
 496 0076 9047     		blx	r2
 497              	.LVL58:
 498 0078 0028     		cmp	r0, #0
 499 007a EFD0     		beq	.L39
 190:Src/cortexm/stm32/stm32f4.c ****         return STM32F4_ERASE_NEVER_END;
 500              		.loc 1 190 0
 501 007c 1948     		ldr	r0, .L49+12
 502 007e FFF7FEFF 		bl	puts
 503              	.LVL59:
 191:Src/cortexm/stm32/stm32f4.c ****       }
 504              		.loc 1 191 0
 505 0082 4FF40060 		mov	r0, #2048
 506              	.LVL60:
 507              	.L35:
 508              	.LBE2:
 207:Src/cortexm/stm32/stm32f4.c **** 
 509              		.loc 1 207 0
 510 0086 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 511              	.LVL61:
 512              	.L45:
 169:Src/cortexm/stm32/stm32f4.c **** 
 513              		.loc 1 169 0
 514 008a 1F36     		adds	r6, r6, #31
 515 008c C4E7     		b	.L36
 516              	.LVL62:
 517              	.L46:
 176:Src/cortexm/stm32/stm32f4.c ****   }
 518              		.loc 1 176 0
 519 008e 2A46     		mov	r2, r5
 520 0090 4146     		mov	r1, r8
 521 0092 2046     		mov	r0, r4
 522 0094 FFF7FEFF 		bl	stm32f4_erase_all_flash
 523              	.LVL63:
 524 0098 F5E7     		b	.L35
 525              	.LVL64:
 526              	.L48:
 527              	.LBB3:
 194:Src/cortexm/stm32/stm32f4.c ****     printf("Flash progress %d\n", *progress);
 528              		.loc 1 194 0 discriminator 2
 529 009a D8F80010 		ldr	r1, [r8]
 530 009e 3144     		add	r1, r1, r6
 531 00a0 C8F80010 		str	r1, [r8]
 195:Src/cortexm/stm32/stm32f4.c ****   }
 532              		.loc 1 195 0 discriminator 2
 533 00a4 1048     		ldr	r0, .L49+16
 534 00a6 FFF7FEFF 		bl	printf
 535              	.LVL65:
 179:Src/cortexm/stm32/stm32f4.c ****     cr = STM32F4_FLASH_CR_EOPIE | STM32F4_FLASH_CR_ERRIE | STM32F4_FLASH_CR_SER;
 536              		.loc 1 179 0 discriminator 2
 537 00aa 0135     		adds	r5, r5, #1
 538              	.LVL66:
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 17


 539 00ac EDB2     		uxtb	r5, r5
 540              	.LVL67:
 541 00ae BAE7     		b	.L37
 542              	.L47:
 543              	.LBE3:
 199:Src/cortexm/stm32/stm32f4.c ****   if ((sr & STM32F4_SR_ERROR_MASK) || !(sr & STM32F4_SR_EOP)) {
 544              		.loc 1 199 0
 545 00b0 2368     		ldr	r3, [r4]
 546 00b2 1A68     		ldr	r2, [r3]
 547 00b4 1268     		ldr	r2, [r2]
 548 00b6 0A49     		ldr	r1, .L49+8
 549 00b8 5868     		ldr	r0, [r3, #4]
 550 00ba 9047     		blx	r2
 551              	.LVL68:
 552 00bc 84B2     		uxth	r4, r0
 553              	.LVL69:
 200:Src/cortexm/stm32/stm32f4.c ****     // TODO: handle error
 554              		.loc 1 200 0
 555 00be 00F0F300 		and	r0, r0, #243
 556 00c2 0128     		cmp	r0, #1
 557 00c4 06D0     		beq	.L43
 202:Src/cortexm/stm32/stm32f4.c ****     return sr | STM32F4_ERASE_ERROR_BIT;
 558              		.loc 1 202 0
 559 00c6 2146     		mov	r1, r4
 560 00c8 0848     		ldr	r0, .L49+20
 561 00ca FFF7FEFF 		bl	printf
 562              	.LVL70:
 203:Src/cortexm/stm32/stm32f4.c ****   }
 563              		.loc 1 203 0
 564 00ce 44F40070 		orr	r0, r4, #512
 565 00d2 D8E7     		b	.L35
 566              	.L43:
 206:Src/cortexm/stm32/stm32f4.c **** }
 567              		.loc 1 206 0
 568 00d4 0020     		movs	r0, #0
 569 00d6 D6E7     		b	.L35
 570              	.L50:
 571              		.align	2
 572              	.L49:
 573 00d8 00000000 		.word	.LC4
 574 00dc 02000103 		.word	50397186
 575 00e0 0C3C0240 		.word	1073888268
 576 00e4 00000000 		.word	.LC1
 577 00e8 24000000 		.word	.LC2
 578 00ec 38000000 		.word	.LC3
 579 00f0 103C0240 		.word	1073888272
 580              		.cfi_endproc
 581              	.LFE134:
 583              		.section	.text.stm32f4_flash_write,"ax",%progbits
 584              		.align	1
 585              		.syntax unified
 586              		.thumb
 587              		.thumb_func
 588              		.fpu fpv4-sp-d16
 590              	stm32f4_flash_write:
 591              	.LFB135:
 210:Src/cortexm/stm32/stm32f4.c ****   uint32_t start_of_ram = 0x20000000;
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 18


 592              		.loc 1 210 0
 593              		.cfi_startproc
 594              		@ args = 0, pretend = 0, frame = 0
 595              		@ frame_needed = 0, uses_anonymous_args = 0
 596              	.LVL71:
 597 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 598              	.LCFI5:
 599              		.cfi_def_cfa_offset 24
 600              		.cfi_offset 3, -24
 601              		.cfi_offset 4, -20
 602              		.cfi_offset 5, -16
 603              		.cfi_offset 6, -12
 604              		.cfi_offset 7, -8
 605              		.cfi_offset 14, -4
 606 0002 0446     		mov	r4, r0
 607 0004 1746     		mov	r7, r2
 608 0006 1D46     		mov	r5, r3
 609              	.LVL72:
 216:Src/cortexm/stm32/stm32f4.c ****   *(uint32_t *)&(stm32f4_flash_write_stub[26]) = len;
 610              		.loc 1 216 0
 611 0008 234A     		ldr	r2, .L59
 612              	.LVL73:
 613 000a 1163     		str	r1, [r2, #48]
 217:Src/cortexm/stm32/stm32f4.c **** 
 614              		.loc 1 217 0
 615 000c 5363     		str	r3, [r2, #52]
 220:Src/cortexm/stm32/stm32f4.c ****   priv->cortex->ops->write_words(priv->cortex->priv, start_of_ram + stub_len, src, len);
 616              		.loc 1 220 0
 617 000e 0068     		ldr	r0, [r0]
 618              	.LVL74:
 619 0010 0368     		ldr	r3, [r0]
 620              	.LVL75:
 621 0012 DE68     		ldr	r6, [r3, #12]
 622 0014 3823     		movs	r3, #56
 623 0016 4FF00051 		mov	r1, #536870912
 624              	.LVL76:
 625 001a 4068     		ldr	r0, [r0, #4]
 626 001c B047     		blx	r6
 627              	.LVL77:
 221:Src/cortexm/stm32/stm32f4.c ****   priv->cortex->ops->pc_write(priv->cortex->priv, start_of_ram);
 628              		.loc 1 221 0
 629 001e 2068     		ldr	r0, [r4]
 630 0020 0368     		ldr	r3, [r0]
 631 0022 DE68     		ldr	r6, [r3, #12]
 632 0024 2B46     		mov	r3, r5
 633 0026 3A46     		mov	r2, r7
 634 0028 1C49     		ldr	r1, .L59+4
 635 002a 4068     		ldr	r0, [r0, #4]
 636 002c B047     		blx	r6
 637              	.LVL78:
 222:Src/cortexm/stm32/stm32f4.c ****   if(priv->cortex->ops->check_error(priv->cortex->priv)) {
 638              		.loc 1 222 0
 639 002e 2368     		ldr	r3, [r4]
 640 0030 1A68     		ldr	r2, [r3]
 641 0032 5269     		ldr	r2, [r2, #20]
 642 0034 4FF00051 		mov	r1, #536870912
 643 0038 5868     		ldr	r0, [r3, #4]
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 19


 644 003a 9047     		blx	r2
 645              	.LVL79:
 223:Src/cortexm/stm32/stm32f4.c ****     // TODO: handle error
 646              		.loc 1 223 0
 647 003c 2368     		ldr	r3, [r4]
 648 003e 1A68     		ldr	r2, [r3]
 649 0040 526A     		ldr	r2, [r2, #36]
 650 0042 5868     		ldr	r0, [r3, #4]
 651 0044 9047     		blx	r2
 652              	.LVL80:
 653 0046 28B9     		cbnz	r0, .L57
 230:Src/cortexm/stm32/stm32f4.c ****   while(!priv->cortex->ops->halt_wait(priv->cortex->priv)) {
 654              		.loc 1 230 0
 655 0048 2368     		ldr	r3, [r4]
 656 004a 1A68     		ldr	r2, [r3]
 657 004c 126A     		ldr	r2, [r2, #32]
 658 004e 5868     		ldr	r0, [r3, #4]
 659 0050 9047     		blx	r2
 660              	.LVL81:
 231:Src/cortexm/stm32/stm32f4.c ****     // Don't be greedy about CPU, allow another task
 661              		.loc 1 231 0
 662 0052 08E0     		b	.L54
 663              	.L57:
 225:Src/cortexm/stm32/stm32f4.c ****     return STM32F4_ERROR_ON_FLASH_WRITE_SETUP;
 664              		.loc 1 225 0
 665 0054 1248     		ldr	r0, .L59+8
 666 0056 FFF7FEFF 		bl	puts
 667              	.LVL82:
 226:Src/cortexm/stm32/stm32f4.c ****   }
 668              		.loc 1 226 0
 669 005a 40F60100 		movw	r0, #2049
 670 005e 13E0     		b	.L51
 671              	.L55:
 233:Src/cortexm/stm32/stm32f4.c ****   }
 672              		.loc 1 233 0
 673 0060 0A20     		movs	r0, #10
 674 0062 FFF7FEFF 		bl	osDelay
 675              	.LVL83:
 676              	.L54:
 231:Src/cortexm/stm32/stm32f4.c ****     // Don't be greedy about CPU, allow another task
 677              		.loc 1 231 0
 678 0066 2368     		ldr	r3, [r4]
 679 0068 1A68     		ldr	r2, [r3]
 680 006a D269     		ldr	r2, [r2, #28]
 681 006c 5868     		ldr	r0, [r3, #4]
 682 006e 9047     		blx	r2
 683              	.LVL84:
 684 0070 0028     		cmp	r0, #0
 685 0072 F5D0     		beq	.L55
 237:Src/cortexm/stm32/stm32f4.c ****   if (sr & STM32F4_SR_ERROR_MASK) {
 686              		.loc 1 237 0
 687 0074 2368     		ldr	r3, [r4]
 688 0076 1A68     		ldr	r2, [r3]
 689 0078 1268     		ldr	r2, [r2]
 690 007a 0A49     		ldr	r1, .L59+12
 691 007c 5868     		ldr	r0, [r3, #4]
 692 007e 9047     		blx	r2
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 20


 693              	.LVL85:
 694 0080 84B2     		uxth	r4, r0
 695              	.LVL86:
 238:Src/cortexm/stm32/stm32f4.c ****     // TODO: handle error
 696              		.loc 1 238 0
 697 0082 14F0F200 		ands	r0, r4, #242
 698 0086 00D1     		bne	.L58
 699              	.LVL87:
 700              	.L51:
 245:Src/cortexm/stm32/stm32f4.c **** 
 701              		.loc 1 245 0
 702 0088 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 703              	.LVL88:
 704              	.L58:
 240:Src/cortexm/stm32/stm32f4.c ****     return sr | STM32F4_FLASH_ERROR_BIT;
 705              		.loc 1 240 0
 706 008a 2146     		mov	r1, r4
 707 008c 0648     		ldr	r0, .L59+16
 708 008e FFF7FEFF 		bl	printf
 709              	.LVL89:
 241:Src/cortexm/stm32/stm32f4.c ****   }
 710              		.loc 1 241 0
 711 0092 44F48060 		orr	r0, r4, #1024
 712 0096 F7E7     		b	.L51
 713              	.L60:
 714              		.align	2
 715              	.L59:
 716 0098 00000000 		.word	.LANCHOR0
 717 009c 38000020 		.word	536870968
 718 00a0 00000000 		.word	.LC5
 719 00a4 0C3C0240 		.word	1073888268
 720 00a8 28000000 		.word	.LC6
 721              		.cfi_endproc
 722              	.LFE135:
 724              		.section	.text.stm32f4_program,"ax",%progbits
 725              		.align	1
 726              		.syntax unified
 727              		.thumb
 728              		.thumb_func
 729              		.fpu fpv4-sp-d16
 731              	stm32f4_program:
 732              	.LFB136:
 248:Src/cortexm/stm32/stm32f4.c ****   UINT br;
 733              		.loc 1 248 0
 734              		.cfi_startproc
 735              		@ args = 0, pretend = 0, frame = 8
 736              		@ frame_needed = 0, uses_anonymous_args = 0
 737              	.LVL90:
 738 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 739              	.LCFI6:
 740              		.cfi_def_cfa_offset 28
 741              		.cfi_offset 4, -28
 742              		.cfi_offset 5, -24
 743              		.cfi_offset 6, -20
 744              		.cfi_offset 7, -16
 745              		.cfi_offset 8, -12
 746              		.cfi_offset 9, -8
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 21


 747              		.cfi_offset 14, -4
 748 0004 2DED028B 		vpush.64	{d8}
 749              	.LCFI7:
 750              		.cfi_def_cfa_offset 36
 751              		.cfi_offset 80, -36
 752              		.cfi_offset 81, -32
 753 0008 83B0     		sub	sp, sp, #12
 754              	.LCFI8:
 755              		.cfi_def_cfa_offset 48
 756 000a 0646     		mov	r6, r0
 757 000c 8846     		mov	r8, r1
 758 000e 1746     		mov	r7, r2
 759              	.LVL91:
 252:Src/cortexm/stm32/stm32f4.c ****   STM32F4_PRIV_t *priv = priv_void;
 760              		.loc 1 252 0
 761 0010 4FF48050 		mov	r0, #4096
 762              	.LVL92:
 763 0014 FFF7FEFF 		bl	pvPortMalloc
 764              	.LVL93:
 765 0018 0546     		mov	r5, r0
 766              	.LVL94:
 255:Src/cortexm/stm32/stm32f4.c **** 
 767              		.loc 1 255 0
 768 001a D8F80C90 		ldr	r9, [r8, #12]
 769              	.LVL95:
 258:Src/cortexm/stm32/stm32f4.c ****   float progress_as_float = 100 * STM32F4_ERASE_TIME_IN_WRITES/(number_of_writes + STM32F4_ERASE_TI
 770              		.loc 1 258 0
 771 001e 09F6FF73 		addw	r3, r9, #4095
 772 0022 1C0B     		lsrs	r4, r3, #12
 773              	.LVL96:
 259:Src/cortexm/stm32/stm32f4.c ****   float progress_on_one_write;
 774              		.loc 1 259 0
 775 0024 04F10A02 		add	r2, r4, #10
 776 0028 4FF47A73 		mov	r3, #1000
 777 002c 93FBF2F3 		sdiv	r3, r3, r2
 778 0030 07EE903A 		vmov	s15, r3	@ int
 779 0034 B8EEE78A 		vcvt.f32.s32	s16, s15
 780              	.LVL97:
 262:Src/cortexm/stm32/stm32f4.c **** 
 781              		.loc 1 262 0
 782 0038 4648     		ldr	r0, .L72
 783              	.LVL98:
 784 003a FFF7FEFF 		bl	puts
 785              	.LVL99:
 264:Src/cortexm/stm32/stm32f4.c ****   stm32f4_flash_unlock(priv);
 786              		.loc 1 264 0
 787 003e 3368     		ldr	r3, [r6]
 788 0040 1A68     		ldr	r2, [r3]
 789 0042 9269     		ldr	r2, [r2, #24]
 790 0044 5868     		ldr	r0, [r3, #4]
 791 0046 9047     		blx	r2
 792              	.LVL100:
 265:Src/cortexm/stm32/stm32f4.c ****   result = stm32f4_erase_flash(priv, file_len, progress, progress_as_float);
 793              		.loc 1 265 0
 794 0048 3046     		mov	r0, r6
 795 004a FFF7FEFF 		bl	stm32f4_flash_unlock
 796              	.LVL101:
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 22


 266:Src/cortexm/stm32/stm32f4.c ****   if(result) {
 797              		.loc 1 266 0
 798 004e FDEEC87A 		vcvt.s32.f32	s15, s16
 799 0052 17EE903A 		vmov	r3, s15	@ int
 800 0056 3A46     		mov	r2, r7
 801 0058 4946     		mov	r1, r9
 802 005a 3046     		mov	r0, r6
 803 005c FFF7FEFF 		bl	stm32f4_erase_flash
 804              	.LVL102:
 805 0060 83B2     		uxth	r3, r0
 806              	.LVL103:
 267:Src/cortexm/stm32/stm32f4.c ****     vPortFree(data);
 807              		.loc 1 267 0
 808 0062 002B     		cmp	r3, #0
 809 0064 4BD1     		bne	.L69
 272:Src/cortexm/stm32/stm32f4.c ****   progress_on_one_write = (100 - *progress)/number_of_writes;
 810              		.loc 1 272 0
 811 0066 D7ED007A 		vldr.32	s15, [r7]	@ int
 812 006a B8EEE78A 		vcvt.f32.s32	s16, s15
 813              	.LVL104:
 273:Src/cortexm/stm32/stm32f4.c **** 
 814              		.loc 1 273 0
 815 006e 17EE903A 		vmov	r3, s15	@ int
 816              	.LVL105:
 817 0072 C3F16403 		rsb	r3, r3, #100
 818 0076 93FBF4F3 		sdiv	r3, r3, r4
 819 007a 07EE903A 		vmov	s15, r3	@ int
 820 007e F8EEE78A 		vcvt.f32.s32	s17, s15
 821              	.LVL106:
 251:Src/cortexm/stm32/stm32f4.c ****   uint32_t *data = pvPortMalloc(STM32F4_SIZE_OF_ONE_WRITE);
 822              		.loc 1 251 0
 823 0082 4FF00064 		mov	r4, #134217728
 824              	.LVL107:
 825              	.L67:
 276:Src/cortexm/stm32/stm32f4.c ****     printf("flash 0x%x bytes on 0x%lx\n", br, addr);
 826              		.loc 1 276 0
 827 0086 01AB     		add	r3, sp, #4
 828 0088 4FF48052 		mov	r2, #4096
 829 008c 2946     		mov	r1, r5
 830 008e 4046     		mov	r0, r8
 831 0090 FFF7FEFF 		bl	f_read
 832              	.LVL108:
 277:Src/cortexm/stm32/stm32f4.c ****     unaligned = br & 0x3;
 833              		.loc 1 277 0
 834 0094 2246     		mov	r2, r4
 835 0096 0199     		ldr	r1, [sp, #4]
 836 0098 2F48     		ldr	r0, .L72+4
 837 009a FFF7FEFF 		bl	printf
 838              	.LVL109:
 278:Src/cortexm/stm32/stm32f4.c ****     if (unaligned) {
 839              		.loc 1 278 0
 840 009e 019B     		ldr	r3, [sp, #4]
 841              	.LVL110:
 279:Src/cortexm/stm32/stm32f4.c ****       // If number of readed bytes % sizeof(uint32_t) != 0, last readed bytes are unaligned.
 842              		.loc 1 279 0
 843 00a0 13F00302 		ands	r2, r3, #3
 844 00a4 32D1     		bne	.L70
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 23


 297:Src/cortexm/stm32/stm32f4.c ****     if(result) {
 845              		.loc 1 297 0
 846 00a6 2A46     		mov	r2, r5
 847 00a8 2146     		mov	r1, r4
 848 00aa 3046     		mov	r0, r6
 849 00ac FFF7FEFF 		bl	stm32f4_flash_write
 850              	.LVL111:
 851 00b0 80B2     		uxth	r0, r0
 852              	.LVL112:
 298:Src/cortexm/stm32/stm32f4.c ****       vPortFree(data);
 853              		.loc 1 298 0
 854 00b2 0028     		cmp	r0, #0
 855 00b4 49D1     		bne	.L71
 302:Src/cortexm/stm32/stm32f4.c **** 
 856              		.loc 1 302 0
 857 00b6 019B     		ldr	r3, [sp, #4]
 858 00b8 1C44     		add	r4, r4, r3
 859              	.LVL113:
 304:Src/cortexm/stm32/stm32f4.c ****     *progress = (int)progress_as_float;
 860              		.loc 1 304 0
 861 00ba 38EE288A 		vadd.f32	s16, s16, s17
 862              	.LVL114:
 305:Src/cortexm/stm32/stm32f4.c ****     printf("Flash progress %d\n", *progress);
 863              		.loc 1 305 0
 864 00be FDEEC87A 		vcvt.s32.f32	s15, s16
 865 00c2 17EE901A 		vmov	r1, s15	@ int
 866 00c6 C7ED007A 		vstr.32	s15, [r7]	@ int
 306:Src/cortexm/stm32/stm32f4.c **** 
 867              		.loc 1 306 0
 868 00ca 2448     		ldr	r0, .L72+8
 869              	.LVL115:
 870 00cc FFF7FEFF 		bl	printf
 871              	.LVL116:
 309:Src/cortexm/stm32/stm32f4.c **** 
 872              		.loc 1 309 0
 873 00d0 019B     		ldr	r3, [sp, #4]
 874 00d2 B3F5805F 		cmp	r3, #4096
 875 00d6 D6D0     		beq	.L67
 876              	.LVL117:
 877              	.L65:
 311:Src/cortexm/stm32/stm32f4.c **** 
 878              		.loc 1 311 0
 879 00d8 2846     		mov	r0, r5
 880 00da FFF7FEFF 		bl	vPortFree
 881              	.LVL118:
 313:Src/cortexm/stm32/stm32f4.c ****   priv->cortex->ops->restart(priv->cortex->priv);
 882              		.loc 1 313 0
 883 00de 2048     		ldr	r0, .L72+12
 884 00e0 FFF7FEFF 		bl	puts
 885              	.LVL119:
 314:Src/cortexm/stm32/stm32f4.c **** 
 886              		.loc 1 314 0
 887 00e4 3368     		ldr	r3, [r6]
 888 00e6 1A68     		ldr	r2, [r3]
 889 00e8 926A     		ldr	r2, [r2, #40]
 890 00ea 5868     		ldr	r0, [r3, #4]
 891 00ec 9047     		blx	r2
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 24


 892              	.LVL120:
 316:Src/cortexm/stm32/stm32f4.c ****   return 0;
 893              		.loc 1 316 0
 894 00ee 6423     		movs	r3, #100
 895 00f0 3B60     		str	r3, [r7]
 317:Src/cortexm/stm32/stm32f4.c **** }
 896              		.loc 1 317 0
 897 00f2 0020     		movs	r0, #0
 898              	.LVL121:
 899              	.L61:
 318:Src/cortexm/stm32/stm32f4.c **** 
 900              		.loc 1 318 0
 901 00f4 03B0     		add	sp, sp, #12
 902              	.LCFI9:
 903              		.cfi_remember_state
 904              		.cfi_def_cfa_offset 36
 905              		@ sp needed
 906 00f6 BDEC028B 		vldm	sp!, {d8}
 907              	.LCFI10:
 908              		.cfi_restore 80
 909              		.cfi_restore 81
 910              		.cfi_def_cfa_offset 28
 911              	.LVL122:
 912 00fa BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 913              	.LVL123:
 914              	.L69:
 915              	.LCFI11:
 916              		.cfi_restore_state
 917 00fe 8146     		mov	r9, r0
 918              	.LVL124:
 268:Src/cortexm/stm32/stm32f4.c ****     return result;
 919              		.loc 1 268 0
 920 0100 2846     		mov	r0, r5
 921 0102 FFF7FEFF 		bl	vPortFree
 922              	.LVL125:
 923 0106 1FFA89F0 		uxth	r0, r9
 269:Src/cortexm/stm32/stm32f4.c ****   }
 924              		.loc 1 269 0
 925 010a F3E7     		b	.L61
 926              	.LVL126:
 927              	.L70:
 283:Src/cortexm/stm32/stm32f4.c ****       data[br] |= ((~0) >> (unaligned << 0x3));
 928              		.loc 1 283 0
 929 010c 9B08     		lsrs	r3, r3, #2
 930              	.LVL127:
 931 010e 0193     		str	r3, [sp, #4]
 932              	.LVL128:
 284:Src/cortexm/stm32/stm32f4.c ****       // add modified bytes to bytes that will be written
 933              		.loc 1 284 0
 934 0110 D200     		lsls	r2, r2, #3
 935 0112 4FF0FF31 		mov	r1, #-1
 936 0116 41FA02F2 		asr	r2, r1, r2
 937 011a 55F82310 		ldr	r1, [r5, r3, lsl #2]
 938 011e 1143     		orrs	r1, r1, r2
 939 0120 45F82310 		str	r1, [r5, r3, lsl #2]
 286:Src/cortexm/stm32/stm32f4.c ****       br <<= 2;
 940              		.loc 1 286 0
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 25


 941 0124 019B     		ldr	r3, [sp, #4]
 942 0126 0133     		adds	r3, r3, #1
 287:Src/cortexm/stm32/stm32f4.c ****       result = stm32f4_flash_write(priv, addr, data, br);
 943              		.loc 1 287 0
 944 0128 9B00     		lsls	r3, r3, #2
 945 012a 0193     		str	r3, [sp, #4]
 288:Src/cortexm/stm32/stm32f4.c ****       if(result) {
 946              		.loc 1 288 0
 947 012c 2A46     		mov	r2, r5
 948 012e 2146     		mov	r1, r4
 949 0130 3046     		mov	r0, r6
 950 0132 FFF7FEFF 		bl	stm32f4_flash_write
 951              	.LVL129:
 952 0136 8146     		mov	r9, r0
 953              	.LVL130:
 954 0138 83B2     		uxth	r3, r0
 955              	.LVL131:
 289:Src/cortexm/stm32/stm32f4.c ****         vPortFree(data);
 956              		.loc 1 289 0
 957 013a 002B     		cmp	r3, #0
 958 013c CCD0     		beq	.L65
 290:Src/cortexm/stm32/stm32f4.c ****         return result;
 959              		.loc 1 290 0
 960 013e 2846     		mov	r0, r5
 961 0140 FFF7FEFF 		bl	vPortFree
 962              	.LVL132:
 963 0144 1FFA89F0 		uxth	r0, r9
 291:Src/cortexm/stm32/stm32f4.c ****       }
 964              		.loc 1 291 0
 965 0148 D4E7     		b	.L61
 966              	.LVL133:
 967              	.L71:
 299:Src/cortexm/stm32/stm32f4.c ****       return 1;
 968              		.loc 1 299 0
 969 014a 2846     		mov	r0, r5
 970              	.LVL134:
 971 014c FFF7FEFF 		bl	vPortFree
 972              	.LVL135:
 300:Src/cortexm/stm32/stm32f4.c ****     }
 973              		.loc 1 300 0
 974 0150 0120     		movs	r0, #1
 975 0152 CFE7     		b	.L61
 976              	.L73:
 977              		.align	2
 978              	.L72:
 979 0154 00000000 		.word	.LC7
 980 0158 18000000 		.word	.LC8
 981 015c 24000000 		.word	.LC2
 982 0160 34000000 		.word	.LC9
 983              		.cfi_endproc
 984              	.LFE136:
 986              		.section	.text.stm32f4_probe,"ax",%progbits
 987              		.align	1
 988              		.global	stm32f4_probe
 989              		.syntax unified
 990              		.thumb
 991              		.thumb_func
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 26


 992              		.fpu fpv4-sp-d16
 994              	stm32f4_probe:
 995              	.LFB139:
 329:Src/cortexm/stm32/stm32f4.c **** 
 330:Src/cortexm/stm32/stm32f4.c **** static TARGET_OPS_t stm32f4_ops = {
 331:Src/cortexm/stm32/stm32f4.c ****   .flash_target = stm32f4_program,
 332:Src/cortexm/stm32/stm32f4.c ****   .reset_target = stm32f4_restart,
 333:Src/cortexm/stm32/stm32f4.c **** 
 334:Src/cortexm/stm32/stm32f4.c ****   .free_priv = stm32f4_free_priv
 335:Src/cortexm/stm32/stm32f4.c **** };
 336:Src/cortexm/stm32/stm32f4.c **** 
 337:Src/cortexm/stm32/stm32f4.c **** static char stm32f4_name[] = "STM32F4x";
 338:Src/cortexm/stm32/stm32f4.c **** 
 339:Src/cortexm/stm32/stm32f4.c **** int stm32f4_probe(CORTEXM_t *cortexm)
 340:Src/cortexm/stm32/stm32f4.c **** {
 996              		.loc 1 340 0
 997              		.cfi_startproc
 998              		@ args = 0, pretend = 0, frame = 0
 999              		@ frame_needed = 0, uses_anonymous_args = 0
 1000              	.LVL136:
 1001 0000 38B5     		push	{r3, r4, r5, lr}
 1002              	.LCFI12:
 1003              		.cfi_def_cfa_offset 16
 1004              		.cfi_offset 3, -16
 1005              		.cfi_offset 4, -12
 1006              		.cfi_offset 5, -8
 1007              		.cfi_offset 14, -4
 1008 0002 0546     		mov	r5, r0
 341:Src/cortexm/stm32/stm32f4.c ****   uint32_t idcode;
 342:Src/cortexm/stm32/stm32f4.c ****   STM32F4_PRIV_t *priv;
 343:Src/cortexm/stm32/stm32f4.c **** 
 344:Src/cortexm/stm32/stm32f4.c ****   idcode = cortexm->ops->read_word(cortexm->priv, STM32F4_DBGMCU_IDCODE);
 1009              		.loc 1 344 0
 1010 0004 0368     		ldr	r3, [r0]
 1011 0006 1B68     		ldr	r3, [r3]
 1012 0008 1249     		ldr	r1, .L80
 1013 000a 4068     		ldr	r0, [r0, #4]
 1014              	.LVL137:
 1015 000c 9847     		blx	r3
 1016              	.LVL138:
 1017 000e 0446     		mov	r4, r0
 1018              	.LVL139:
 345:Src/cortexm/stm32/stm32f4.c ****   printf("STM32F4 probed id code: 0x%lx\n", idcode);
 1019              		.loc 1 345 0
 1020 0010 0146     		mov	r1, r0
 1021 0012 1148     		ldr	r0, .L80+4
 1022              	.LVL140:
 1023 0014 FFF7FEFF 		bl	printf
 1024              	.LVL141:
 346:Src/cortexm/stm32/stm32f4.c **** 
 347:Src/cortexm/stm32/stm32f4.c ****   switch (idcode & 0xFFF) {
 1025              		.loc 1 347 0
 1026 0018 C4F30B04 		ubfx	r4, r4, #0, #12
 1027              	.LVL142:
 1028 001c A4F21144 		subw	r4, r4, #1041
 1029 0020 122C     		cmp	r4, #18
 1030 0022 15D8     		bhi	.L78
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 27


 1031 0024 DFE804F0 		tbb	[pc, r4]
 1032              	.L77:
 1033 0028 0A       		.byte	(.L76-.L77)/2
 1034 0029 14       		.byte	(.L78-.L77)/2
 1035 002a 0A       		.byte	(.L76-.L77)/2
 1036 002b 14       		.byte	(.L78-.L77)/2
 1037 002c 14       		.byte	(.L78-.L77)/2
 1038 002d 14       		.byte	(.L78-.L77)/2
 1039 002e 14       		.byte	(.L78-.L77)/2
 1040 002f 14       		.byte	(.L78-.L77)/2
 1041 0030 0A       		.byte	(.L76-.L77)/2
 1042 0031 14       		.byte	(.L78-.L77)/2
 1043 0032 14       		.byte	(.L78-.L77)/2
 1044 0033 14       		.byte	(.L78-.L77)/2
 1045 0034 14       		.byte	(.L78-.L77)/2
 1046 0035 14       		.byte	(.L78-.L77)/2
 1047 0036 14       		.byte	(.L78-.L77)/2
 1048 0037 14       		.byte	(.L78-.L77)/2
 1049 0038 14       		.byte	(.L78-.L77)/2
 1050 0039 14       		.byte	(.L78-.L77)/2
 1051 003a 0A       		.byte	(.L76-.L77)/2
 1052 003b 00       		.p2align 1
 1053              	.L76:
 348:Src/cortexm/stm32/stm32f4.c ****     case 0x411: /* Documented to be 0x413! This is what I read... */
 349:Src/cortexm/stm32/stm32f4.c ****     case 0x413:
 350:Src/cortexm/stm32/stm32f4.c ****     case 0x423: /* F401 */
 351:Src/cortexm/stm32/stm32f4.c ****     case 0x419: /* 427/437 */
 352:Src/cortexm/stm32/stm32f4.c ****       priv = pvPortMalloc(sizeof(STM32F4_PRIV_t));
 1054              		.loc 1 352 0
 1055 003c 0420     		movs	r0, #4
 1056 003e FFF7FEFF 		bl	pvPortMalloc
 1057              	.LVL143:
 353:Src/cortexm/stm32/stm32f4.c ****       priv->cortex = cortexm;
 1058              		.loc 1 353 0
 1059 0042 0560     		str	r5, [r0]
 354:Src/cortexm/stm32/stm32f4.c ****       register_target(priv, &stm32f4_ops, stm32f4_name);
 1060              		.loc 1 354 0
 1061 0044 054A     		ldr	r2, .L80+8
 1062 0046 0649     		ldr	r1, .L80+12
 1063 0048 FFF7FEFF 		bl	register_target
 1064              	.LVL144:
 355:Src/cortexm/stm32/stm32f4.c ****       return 1;
 1065              		.loc 1 355 0
 1066 004c 0120     		movs	r0, #1
 1067 004e 00E0     		b	.L74
 1068              	.L78:
 356:Src/cortexm/stm32/stm32f4.c ****   }
 357:Src/cortexm/stm32/stm32f4.c **** 
 358:Src/cortexm/stm32/stm32f4.c ****   return 0;
 1069              		.loc 1 358 0
 1070 0050 0020     		movs	r0, #0
 1071              	.L74:
 359:Src/cortexm/stm32/stm32f4.c **** }
 1072              		.loc 1 359 0
 1073 0052 38BD     		pop	{r3, r4, r5, pc}
 1074              	.LVL145:
 1075              	.L81:
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 28


 1076              		.align	2
 1077              	.L80:
 1078 0054 002004E0 		.word	-536600576
 1079 0058 00000000 		.word	.LC10
 1080 005c 00000000 		.word	.LANCHOR1
 1081 0060 00000000 		.word	.LANCHOR2
 1082              		.cfi_endproc
 1083              	.LFE139:
 1085              		.section	.data.stm32f4_flash_write_stub,"aw",%progbits
 1086              		.align	2
 1087              		.set	.LANCHOR0,. + 0
 1090              	stm32f4_flash_write_stub:
 1091 0000 0A48     		.short	18442
 1092 0002 0B49     		.short	18699
 1093 0004 7A46     		.short	18042
 1094 0006 3032     		.short	12848
 1095 0008 0A4B     		.short	19210
 1096 000a 074D     		.short	19719
 1097 000c 53B1     		.short	-20141
 1098 000e 0561     		.short	24837
 1099 0010 1468     		.short	26644
 1100 0012 0C60     		.short	24588
 1101 0014 C489     		.short	-30268
 1102 0016 0126     		.short	9729
 1103 0018 3442     		.short	16948
 1104 001a FBD1     		.short	-11781
 1105 001c 043B     		.short	15108
 1106 001e 0431     		.short	12548
 1107 0020 0432     		.short	12804
 1108 0022 F3E7     		.short	-6157
 1109 0024 00BE     		.short	-16896
 1110 0026 0000     		.short	0
 1111 0028 0102     		.short	513
 1112 002a 0000     		.short	0
 1113 002c 003C     		.short	15360
 1114 002e 0240     		.short	16386
 1115 0030 0000     		.short	0
 1116 0032 0000     		.short	0
 1117 0034 0000     		.short	0
 1118 0036 0000     		.short	0
 1119              		.section	.data.stm32f4_name,"aw",%progbits
 1120              		.align	2
 1121              		.set	.LANCHOR1,. + 0
 1124              	stm32f4_name:
 1125 0000 53544D33 		.ascii	"STM32F4x\000"
 1125      32463478 
 1125      00
 1126              		.section	.data.stm32f4_ops,"aw",%progbits
 1127              		.align	2
 1128              		.set	.LANCHOR2,. + 0
 1131              	stm32f4_ops:
 1132 0000 00000000 		.word	stm32f4_program
 1133 0004 00000000 		.word	stm32f4_restart
 1134 0008 00000000 		.word	stm32f4_free_priv
 1135              		.section	.rodata.stm32f4_erase_all_flash.str1.4,"aMS",%progbits,1
 1136              		.align	2
 1137              	.LC1:
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 29


 1138 0000 4572726F 		.ascii	"Error while waiting for erase end\000"
 1138      72207768 
 1138      696C6520 
 1138      77616974 
 1138      696E6720 
 1139 0022 0000     		.space	2
 1140              	.LC2:
 1141 0024 466C6173 		.ascii	"Flash progress %d\012\000"
 1141      68207072 
 1141      6F677265 
 1141      73732025 
 1141      640A00
 1142 0037 00       		.space	1
 1143              	.LC3:
 1144 0038 4572726F 		.ascii	"Error after erase 0x%x\012\000"
 1144      72206166 
 1144      74657220 
 1144      65726173 
 1144      65203078 
 1145              		.section	.rodata.stm32f4_erase_flash.str1.4,"aMS",%progbits,1
 1146              		.align	2
 1147              	.LC4:
 1148 0000 45726173 		.ascii	"Erase Flash\000"
 1148      6520466C 
 1148      61736800 
 1149              		.section	.rodata.stm32f4_flash_unlock.str1.4,"aMS",%progbits,1
 1150              		.align	2
 1151              	.LC0:
 1152 0000 466C6173 		.ascii	"Flash unlock\000"
 1152      6820756E 
 1152      6C6F636B 
 1152      00
 1153              		.section	.rodata.stm32f4_flash_write.str1.4,"aMS",%progbits,1
 1154              		.align	2
 1155              	.LC5:
 1156 0000 4552524F 		.ascii	"ERROR: Filed to setup write operation\000"
 1156      523A2046 
 1156      696C6564 
 1156      20746F20 
 1156      73657475 
 1157 0026 0000     		.space	2
 1158              	.LC6:
 1159 0028 4552524F 		.ascii	"ERROR: writing ended with error 0x%x\012\000"
 1159      523A2077 
 1159      72697469 
 1159      6E672065 
 1159      6E646564 
 1160              		.section	.rodata.stm32f4_probe.str1.4,"aMS",%progbits,1
 1161              		.align	2
 1162              	.LC10:
 1163 0000 53544D33 		.ascii	"STM32F4 probed id code: 0x%lx\012\000"
 1163      32463420 
 1163      70726F62 
 1163      65642069 
 1163      6420636F 
 1164              		.section	.rodata.stm32f4_program.str1.4,"aMS",%progbits,1
 1165              		.align	2
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 30


 1166              	.LC7:
 1167 0000 53746172 		.ascii	"Start flashing STM32F4x\000"
 1167      7420666C 
 1167      61736869 
 1167      6E672053 
 1167      544D3332 
 1168              	.LC8:
 1169 0018 666C6173 		.ascii	"flash 0x%x bytes on 0x%lx\012\000"
 1169      68203078 
 1169      25782062 
 1169      79746573 
 1169      206F6E20 
 1170 0033 00       		.space	1
 1171              	.LC9:
 1172 0034 44657669 		.ascii	"Device flashed\012Reset device\000"
 1172      63652066 
 1172      6C617368 
 1172      65640A52 
 1172      65736574 
 1173              		.text
 1174              	.Letext0:
 1175              		.file 2 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/machine/_defau
 1176              		.file 3 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_stdint.h"
 1177              		.file 4 "Drivers/CMSIS/Include/core_cm4.h"
 1178              		.file 5 "Drivers/CMSIS/Device/ST/STM32F4xx/Include/system_stm32f4xx.h"
 1179              		.file 6 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/lock.h"
 1180              		.file 7 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/_types.h"
 1181              		.file 8 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/lib/gcc/arm-none-eabi/7.2.1/include/
 1182              		.file 9 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/sys/reent.h"
 1183              		.file 10 "Middlewares/Third_Party/FreeRTOS/Source/include/task.h"
 1184              		.file 11 "Middlewares/Third_Party/FreeRTOS/Source/include/queue.h"
 1185              		.file 12 "Middlewares/Third_Party/FreeRTOS/Source/include/semphr.h"
 1186              		.file 13 "Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS/cmsis_os.h"
 1187              		.file 14 "Inc/cortexm/cortexm.h"
 1188              		.file 15 "Inc/cortexm/stm32/stm32f4.h"
 1189              		.file 16 "Middlewares/Third_Party/FatFs/src/integer.h"
 1190              		.file 17 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/stdlib.h"
 1191              		.file 18 "Middlewares/ST/STM32_USB_Host_Library/Core/Inc/usbh_def.h"
 1192              		.file 19 "Middlewares/ST/STM32_USB_Host_Library/Core/Inc/usbh_ctlreq.h"
 1193              		.file 20 "Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc/usbh_msc.h"
 1194              		.file 21 "Middlewares/Third_Party/FatFs/src/ff.h"
 1195              		.file 22 "Middlewares/Third_Party/FatFs/src/diskio.h"
 1196              		.file 23 "Middlewares/Third_Party/FatFs/src/ff_gen_drv.h"
 1197              		.file 24 "Inc/usbh_diskio.h"
 1198              		.file 25 "Inc/fatfs.h"
 1199              		.file 26 "Inc/target.h"
 1200              		.file 27 "/usr/local/gcc_arm/gcc-arm-none-eabi-7-2017-q4-major/arm-none-eabi/include/stdio.h"
 1201              		.file 28 "Middlewares/Third_Party/FreeRTOS/Source/include/portable.h"
 1202              		.file 29 "<built-in>"
ARM GAS  /var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s 			page 31


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f4.c
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:18     .text.stm32f4_sectors_in_bank1:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:24     .text.stm32f4_sectors_in_bank1:0000000000000000 stm32f4_sectors_in_bank1
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:59     .text.stm32f4_sectors_in_bank1:000000000000001c $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:68     .text.stm32f4_sectors_in_bank1:0000000000000040 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:94     .text.stm32f4_restart:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:100    .text.stm32f4_restart:0000000000000000 stm32f4_restart
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:126    .text.stm32f4_free_priv:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:132    .text.stm32f4_free_priv:0000000000000000 stm32f4_free_priv
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:162    .text.stm32f4_flash_unlock:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:168    .text.stm32f4_flash_unlock:0000000000000000 stm32f4_flash_unlock
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:224    .text.stm32f4_flash_unlock:000000000000003c $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:233    .text.stm32f4_erase_all_flash:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:239    .text.stm32f4_erase_all_flash:0000000000000000 stm32f4_erase_all_flash
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:387    .text.stm32f4_erase_all_flash:00000000000000bc $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:398    .text.stm32f4_erase_flash:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:404    .text.stm32f4_erase_flash:0000000000000000 stm32f4_erase_flash
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:573    .text.stm32f4_erase_flash:00000000000000d8 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:584    .text.stm32f4_flash_write:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:590    .text.stm32f4_flash_write:0000000000000000 stm32f4_flash_write
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:716    .text.stm32f4_flash_write:0000000000000098 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:725    .text.stm32f4_program:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:731    .text.stm32f4_program:0000000000000000 stm32f4_program
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:979    .text.stm32f4_program:0000000000000154 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:987    .text.stm32f4_probe:0000000000000000 $t
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:994    .text.stm32f4_probe:0000000000000000 stm32f4_probe
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1033   .text.stm32f4_probe:0000000000000028 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1078   .text.stm32f4_probe:0000000000000054 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1086   .data.stm32f4_flash_write_stub:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1090   .data.stm32f4_flash_write_stub:0000000000000000 stm32f4_flash_write_stub
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1120   .data.stm32f4_name:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1124   .data.stm32f4_name:0000000000000000 stm32f4_name
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1127   .data.stm32f4_ops:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1131   .data.stm32f4_ops:0000000000000000 stm32f4_ops
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1136   .rodata.stm32f4_erase_all_flash.str1.4:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1146   .rodata.stm32f4_erase_flash.str1.4:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1150   .rodata.stm32f4_flash_unlock.str1.4:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1154   .rodata.stm32f4_flash_write.str1.4:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1161   .rodata.stm32f4_probe.str1.4:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1165   .rodata.stm32f4_program.str1.4:0000000000000000 $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1052   .text.stm32f4_probe:000000000000003b $d
/var/folders/0d/93p3r6493yg7p0rvl_4r983m0000gn/T//ccDTWxZF.s:1052   .text.stm32f4_probe:000000000000003c $t

UNDEFINED SYMBOLS
vPortFree
puts
osDelay
printf
pvPortMalloc
f_read
register_target
